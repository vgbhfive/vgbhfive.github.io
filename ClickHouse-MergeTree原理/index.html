<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="https://i.loli.net/2019/12/10/JF3dKDSkZoPz7h6.jpg">
  <link rel="icon" type="image/png" sizes="16x16" href="https://i.loli.net/2019/12/10/JF3dKDSkZoPz7h6.jpg">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">
  <meta name="google-site-verification" content="G-QBK8PCQC9B">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"blog.vgbhfive.cn","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":true,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":"gitalk","storage":true,"lazyload":false,"nav":null,"activeClass":"gitalk"},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="引入表引擎是 ClickHouse 设计实现的一大特色，也可以说是表引擎成就了一张表的最终面貌。">
<meta property="og:type" content="article">
<meta property="og:title" content="ClickHouse-MergeTree原理">
<meta property="og:url" content="https://blog.vgbhfive.cn/ClickHouse-MergeTree%E5%8E%9F%E7%90%86/index.html">
<meta property="og:site_name" content="Vgbhfive&#39;s Blog">
<meta property="og:description" content="引入表引擎是 ClickHouse 设计实现的一大特色，也可以说是表引擎成就了一张表的最终面貌。">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://s2.loli.net/2022/08/02/J7XR9l5MngsxYUh.jpg">
<meta property="og:image" content="https://s2.loli.net/2022/08/06/zZxB9MF6G1Rjgkp.jpg">
<meta property="og:image" content="https://s2.loli.net/2022/08/06/YGCE16QrRgH7M2O.png">
<meta property="og:image" content="https://s2.loli.net/2022/08/07/mn78HpxLhfSUwTN.jpg">
<meta property="og:image" content="https://s2.loli.net/2022/08/07/m7zwiE3HQfaKRrZ.jpg">
<meta property="og:image" content="https://s2.loli.net/2022/08/08/ZxSk8mAEG31JaQf.png">
<meta property="og:image" content="https://s2.loli.net/2022/08/08/MgqKXhi8ysPpxmn.png">
<meta property="og:image" content="https://s2.loli.net/2022/08/09/X97lhzTVn6sdwWE.png">
<meta property="og:image" content="https://s2.loli.net/2022/08/23/dM58XwQJVgL6o1Z.png">
<meta property="article:published_time" content="2022-07-31T05:57:06.000Z">
<meta property="article:modified_time" content="2023-01-01T15:47:48.000Z">
<meta property="article:author" content="vgbhfive">
<meta property="article:tag" content="ClickHouse">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://s2.loli.net/2022/08/02/J7XR9l5MngsxYUh.jpg">

<link rel="canonical" href="https://blog.vgbhfive.cn/ClickHouse-MergeTree%E5%8E%9F%E7%90%86/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'en'
  };
</script>

  <title>ClickHouse-MergeTree原理 | Vgbhfive's Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<link rel="alternate" href="/atom.xml" title="Vgbhfive's Blog" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Vgbhfive's Blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>About</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-pictures">

    <a href="/pictures/" rel="section"><i class="fa fa-th fa-fw"></i>Pictures</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
        <li class="menu-item menu-item-sitemap">

    <a href="/sitemap.xml" rel="section"><i class="fa fa-sitemap fa-fw"></i>Sitemap</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="reading-progress-bar"></div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://blog.vgbhfive.cn/ClickHouse-MergeTree%E5%8E%9F%E7%90%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://i.loli.net/2019/12/10/JF3dKDSkZoPz7h6.jpg">
      <meta itemprop="name" content="vgbhfive">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Vgbhfive's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          ClickHouse-MergeTree原理
        </h1>

        <div class="post-meta">
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-07-31 13:57:06" itemprop="dateCreated datePublished" datetime="2022-07-31T13:57:06+08:00">2022-07-31</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2023-01-01 23:47:48" itemprop="dateModified" datetime="2023-01-01T23:47:48+08:00">2023-01-01</time>
              </span>

          
            <span class="post-meta-item" title="Views" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">Views: </span>
              <span id="busuanzi_value_page_pv"></span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h3 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h3><p>表引擎是 <code>ClickHouse</code> 设计实现的一大特色，也可以说是表引擎成就了一张表的最终<em>面貌</em>。</p>
<span id="more"></span>

<hr>

<h3 id="创建方式"><a href="#创建方式" class="headerlink" title="创建方式"></a>创建方式</h3><p><code>MergeTree</code> 在写入一批数据时，数据总会以片段的形式写入磁盘，且数据片段不能修改，但为了避免数据片段过多，<code>ClickHouse</code> 会在后台线程定期合并这些数据片段，属于相同分区的数据片段会被合并成一个新的片段。这种合并的特征也就是合并树名称的由来。</p>
<p>创建 <code>MergeTree</code> 数据表的方式与之前的方式一样，但需要将 <code>ENGINE</code> 声明为 <code>MergeTree()</code>。另外 <code>MergeTree()</code> 表引擎除了常规的配置参数之外，还有独有的配置选项。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> [IF <span class="keyword">NOT</span> <span class="keyword">EXISTS</span>] [db_name.]table_name (</span><br><span class="line">    name1 [type] [<span class="keyword">DEFAULT</span><span class="operator">|</span>MATERIALIZED<span class="operator">|</span>ALIAS expr],</span><br><span class="line">    name2 [type] [<span class="keyword">DEFAULT</span><span class="operator">|</span>MATERIALIZED<span class="operator">|</span>ALIAS expr]</span><br><span class="line">) ENGINE <span class="operator">=</span> MergeTree()</span><br><span class="line">[<span class="keyword">PARTITION</span> <span class="keyword">BY</span> expr]</span><br><span class="line">[<span class="keyword">ORDER</span> <span class="keyword">BY</span> expr]</span><br><span class="line">[<span class="keyword">PRIMARY</span> KEY expr]</span><br><span class="line">[SAMPLE <span class="keyword">BY</span> expr]</span><br><span class="line">[SETTING name<span class="operator">=</span><span class="keyword">value</span>, ...]</span><br></pre></td></tr></table></figure>
<ol>
<li><p><code>PARTITION BY expr</code> 分区键，用于指定表数据以何种标准进行分区。其中分区键既可以是单个列字段，也可以是通过元组的形式使用多个列字段，同时它也支持使用列表达式，如果不声明分区键则 <code>ClickHouse</code> 会自动生成一个名为 <code>all</code> 的分区。</p>
</li>
<li><p><code>ORDER BY expr</code> 排序键，用于指定在一个数据片段内，数据以何种方式标准排序。默认情况下主键与排序键相同。</p>
</li>
<li><p><code>PRIMARY KEY expr</code> 主键，声明后会依靠主键生成一级索引，用于加速表查询。默认情况下，主键与排序键相同，所以通常使用 <code>ORDER BY</code> 代为指定主键。</p>
</li>
<li><p><code>SAMPLE BY</code> 抽样表达式，用于声明数据以何种标准进行采样。</p>
</li>
<li><p><code>SETTINGS key=value</code> 设置表引擎参数。</p>
<ul>
<li><code>index_granulatrity</code> 表示索引粒度，默认值为 <code>8192</code>。</li>
<li><code>index_granulatrity_bytes</code> 表示索引间隔大小，即控制每一批次写入数据的题量大小，默认为 <code>10M</code>，当设置为 <code>0</code> 时表示不启动自适应功能。</li>
<li><code>enabled_mixed_granulatrity_parts</code> 表示是否开启自适应索引间隔的功能，默认开启。</li>
<li><code>merge_with_ttl_timeout</code> 数据 <code>TTL</code> 的功能。</li>
<li><code>storage_policy</code> 多路径存储策略。</li>
</ul>
</li>
</ol>
<hr>

<h3 id="存储结构"><a href="#存储结构" class="headerlink" title="存储结构"></a>存储结构</h3><p><code>MergeTree</code> 表引擎中的数据是拥有物理存储的，数据会按照分区目录的形式保存到磁盘上。<br><img src="https://s2.loli.net/2022/08/02/J7XR9l5MngsxYUh.jpg" alt="click-3-1.jpg"></p>
<ol>
<li><p><code>partition</code> 分区目录，余下的各类数据文件都是以分区目录的形式被组织存储的，属于相同分区的数据最终都会被合并到同一个分区目录，而不同分区的数据永远不会被合并。</p>
</li>
<li><p><code>checksums.txt</code> 校验文件，使用二进制格式存储。它保存了余下各类文件的 <code>size</code> 大小和 <code>size</code> 的哈希值，用于快速校验文件的完整性和正确性。</p>
</li>
<li><p><code>columns.txt</code> 列信息文件，使用明文格式存储。用于保存此数据分区下的列字段信息。</p>
</li>
<li><p><code>count.txt</code> 计数文件，使用明文格式存储。用于记录当前数据分区目录下数据的总行数。</p>
</li>
<li><p><code>primary.txt</code> 一级索引文件，使用二进制格式存储。用于存放稀疏索引，一张 <code>MergeTree</code> 表只能声明一次一级索引。通过一级索引可以在查询数据时排除主键条件范围之外的数据文件，从而有效减少数据扫描范围，加速查询速度。</p>
</li>
<li><p><code>[Column].bin</code> 数据文件，使用压缩格式存储，默认为 <code>LZ4</code> 压缩格式，用于存储某一列的数据。由于 <code>MergeTree</code> 采用列式存储，所以每一列字段都拥有独立的 <code>.bin</code> 数据文件，并以列字段名称命名。</p>
</li>
<li><p><code>[Column].mrk</code> 列字段标记文件，使用二进制格式存储。标记文件中保存 <code>.bin</code> 文件中数据的偏移量信息。标记文件与稀疏索引对齐，又与 <code>.bin</code> 文件一一对应，即 <code>MergeTree</code> 通过标记文件建立了 <code>primary.idx</code> 稀疏索引与 <code>.bin</code> 数据文件之间映射关系。即首先通过稀疏索引找到对应数据的偏移量信息，再通过偏移量从 <code>.bin</code> 文件中读取数据，由于 <code>.bin</code> 文件与 <code>.mrk</code> 标记文件一一对应，所以 <code>MergeTree</code> 中的每个列字段都会拥有与其对应的 <code>.mrk</code> 标记文件。</p>
</li>
<li><p><code>[Column].mrk2</code> 若使用了自适应大小的索引间隔，则标记文件会以 <code>.mrk2</code> 命名，工作原理和作用与 <code>.mrk</code> 标记文件相同。</p>
</li>
<li><p><code>partition.dat</code> 和 <code>minmax_[Column].idx</code> 若使用了分区键，则会生成 <code>partition.dat</code> 和 <code>minmax</code> 索引文件，均使用二进制格式存储。其中 <code>partition.dat</code> 用于保存当前分区下分区表达式最终生成的值；而 <code>minmax</code> 索引用于记录当前分区下分区字段对应原始数据的最小和最大值。 </p>
</li>
<li><p><code>skp_idx_[Column].idx</code> 和 <code>skp_idx_[Column].mrk</code> 若在建表语句中声明了二级索引，则会额外生成相应的的二级索引与标记文件，也是使用二进制存储。同时二级索引又被称为跳数索引，目前拥有 <code>minmax</code>、 <code>set</code>、 <code>ngrambf_v1</code> 和 <code>tokenbf_v1</code> 四种类型，这些索引与一级稀疏索引相同，都是为了进一步减少所需扫描的数据范围，以加速整个查询过程。</p>
</li>
</ol>
<hr>

<h3 id="数据分区"><a href="#数据分区" class="headerlink" title="数据分区"></a>数据分区</h3><p>在 <code>ClickHouse</code> 中数据分区（<code>partition</code>）和数据分区（<code>shard</code>）是完全不同的概念。数据分区是针对本地数据而言的，是对数据的一种<strong>纵向切分</strong>，<code>MergeTree</code> 并不能依靠数据分区的特性，将一张表的数据分布到多个 <code>ClickHouse</code> 节点中。而数据分片则是对数据进行<strong>横向切分</strong>。</p>
<h4 id="分区规则"><a href="#分区规则" class="headerlink" title="分区规则"></a>分区规则</h4><p><code>MergeTree</code> 数据分区的规则是由分区 <code>ID</code> 决定的，而具体到每个数据分区所对应的 <code>ID</code>，则是由分区键的取值决定的。<br>分区键支持使用一个或一组表达式声明，其业务语义可以是年、月、日或时等任何一种限制。针对不同取值类型，分区 <code>ID</code> 的生成逻辑目前有四种逻辑：</p>
<ul>
<li>不指定分区键，如果不使用分区键，即不使用 <code>PARTITION BY</code> 声明任何分区表达式，则分区 <code>ID</code> 默认取名为 <code>all</code>，所有的数据都会被写入到这个 <code>all</code> 分区。</li>
<li>使用整数，如果分区键取值属于整形，且无法转换为日期类型，则直接按照该整形的字符串形式输出，作为分区 <code>ID</code> 的取值。</li>
<li>使用日期类型，如果分区键取值属于日期类型，或者能转换为日期类型，则可以按照 <code>YYYYMMDD</code> 格式化后的字符串形式输出，作为分区 <code>ID</code> 的取值。</li>
<li>使用其他类型，如果分区键既不属于整形，也不属于日期类型，则通过 <code>128</code> 位 <code>Hash</code> 算法取其 <code>Hash</code> 值作为分区 <code>ID</code> 的取值。</li>
</ul>
<p><small>如果通过元组的形式使用多个分区字段，则分区 <code>ID</code> 依旧是按照上述规则生成，只是多个 <code>ID</code> 之间通过 <code>-</code> 符号依次连接。</small></p>
<h4 id="分区目录的命名规则"><a href="#分区目录的命名规则" class="headerlink" title="分区目录的命名规则"></a>分区目录的命名规则</h4><p>完整分区目录的命名公式所示：<code>PartitionID_MinBlockNum_MaxBlockNum_Level</code>。</p>
<ul>
<li><code>partitionID</code> 分区 <code>ID</code>。</li>
<li><code>MinBlockNum</code> 和 <code>MaxBlockNum</code> 顾名思义最小数据块编号和最大数据块编号。</li>
<li><code>Level</code> 合并的层级，可以理解为某个分区被合并的次数，或者为这个分区的年龄。</li>
</ul>
<h4 id="分区目录的合并过程"><a href="#分区目录的合并过程" class="headerlink" title="分区目录的合并过程"></a>分区目录的合并过程</h4><p><code>MergeTree</code> 的分区目录在某种意义上与其他数据库是不同的。<br>首先，<code>MergeTree</code> 的分区目录并不是在数据表被创建之后就存在的，而是在数据被写入过程中被 创建。即没有数据时分区目录是不存在的。<br>其次，分区目录在建立之后并不是一成不变的，在其他的数据库中，追加数据后目录自身并不会变化，只是在相同目录下添加数据文件。而 <code>MeregTree</code> 完全不同，在每一批数据写入后都会生成一批新的目录（即便是不同批次属于相同的数据，都会生成不同的分区目录）。而在这之后的某个时刻 <code>ClickHouse</code> 会通过后台任务将属于相同分区的多个目录进行合并成一个新的目录，已经存在的旧分区目录不会被立即删除，而是在这之后的某个时刻通过后台任务被删除。</p>
<p>属于同一个分区的多个目录在合并之后会生成一个新的目录，目录中的索引和数据文件都会被合并。新的目录名称的合并方式遵循以下规则，其中：</p>
<ul>
<li><code>MinBlockNum</code> 取同一分区内所有目录中最小的 <code>MinBlockNum</code> 值。</li>
<li><code>MaxBlockNum</code> 取同一分区内所有目录中最大的 <code>MaxBlockNum</code> 值。</li>
<li><code>Level</code> 取同一分区最大 <code>Level</code> 值并加一。</li>
</ul>
<p><img src="https://s2.loli.net/2022/08/06/zZxB9MF6G1Rjgkp.jpg" alt="neo4j-3-2.jpg"></p>
<p><small>分区目录在合并之后，旧分区目录并没有被删除，但旧分区目录的状态却不是激活状态，因此在查询数据时，会被自动过滤。</small></p>
<hr>

<h3 id="一级索引"><a href="#一级索引" class="headerlink" title="一级索引"></a>一级索引</h3><p><code>MergeTree</code> 的主键使用 <code>PRIMARY KEY</code> 定义，待主键定义之后 <code>MergeTree</code> 会依据 <code>index_granularity</code> 间隔为数据表生成一级索引并保存至 <code>primary.idx</code> 文件内，索引数据按照 <code>PRIMARY KEY</code> 排序。</p>
<h4 id="稀疏索引"><a href="#稀疏索引" class="headerlink" title="稀疏索引"></a>稀疏索引</h4><p><code>primary.idx</code> 文件内的一级索引采用稀疏索引实现。<br><img src="https://s2.loli.net/2022/08/06/YGCE16QrRgH7M2O.png" alt="neo4j-3-3.jpg"></p>
<p>简单来说，在稠密索引中每一行索引标记都会对应一行具体的数据记录，而在稀疏索引中每一行索引标记的是每一段数据，而不是一行。</p>
<p><small>稀疏索引的优势显而易见，仅需要使用少量的索引标记就能够记录大量数据的区间信息，且数据越大优势越明显。</small></p>
<h4 id="索引粒度"><a href="#索引粒度" class="headerlink" title="索引粒度"></a>索引粒度</h4><p>索引粒度对于 <code>MergeTree</code> 是一个非常重要的 <code>Point</code>，所以很有必要着重说明一下。索引粒度就犹如<em>标尺</em>一样会丈量整个数据的长度，并依照刻度对数据进行标注，最终将数据标记成多个间隔的小段。</p>
<p>数据以 <code>index_granularity</code> 粒度被标记成多个小区间，其中每个区间之间最多间隔 <code>index_granularity</code> 行数据。<code>MergeTree</code> 使用 <code>MarkRange</code> 表示一个具体的区间，并通过 <code>start</code> 和 <code>end</code> 表示具体的范围。<br><code>index_granularity</code> 的命名中包含索引，但并不仅作用于一级索引，同时也会影响数据标记 <code>.mrk</code> 和数据文件 <code>.bin</code>，因为仅借助一级索引是无法完成查询的，需要借助数据标记才能定位具体数据。</p>
<h4 id="索引数据的生成规则"><a href="#索引数据的生成规则" class="headerlink" title="索引数据的生成规则"></a>索引数据的生成规则</h4><p>由于是稀疏索引所以 <code>MergeTree</code> 需要间隔 <code>index_granularity</code> 行数据才会生成一条索引记录，其索引值会依据声明的主键字段获取。<br><img src="https://s2.loli.net/2022/08/07/mn78HpxLhfSUwTN.jpg" alt="neo4j-3-4.jpg"></p>
<p><small><code>A00A8192A16384</code> 在 <code>MergeTree</code> 对于稀疏索引的存储是非常紧凑的，索引值前后相连，按照主键字段顺序紧密的列在一起。</small></p>
<h4 id="索引的查询过程"><a href="#索引的查询过程" class="headerlink" title="索引的查询过程"></a>索引的查询过程</h4><p>前面说过了 <code>MarkRange</code> 是用于在 <code>ClickHouse</code> 中用于定义标记区间的对象。<code>MergeTree</code> 按照 <code>index_granularity</code> 的间隔粒度，将一段完整的数据划分为多个小的间隔数据，一个具体的数据段即一个 <code>MarkRange</code>，与索引编号一一对应，使用 <code>start</code> 和 <code>end</code> 两个属性表示其区间范围，通过 <code>start</code> 和 <code>end</code> 对应的索引编号的取值即能够得到对应的数值区间，而数值区间即此 <code>MarkRange</code> 包含的数据范围。</p>
<p><img src="https://s2.loli.net/2022/08/07/m7zwiE3HQfaKRrZ.jpg" alt="neo4j-3-5.jpg"><br>索引查询其本质就是两个数值区间的交集判断，其中一个区间是由基于主键的查询条件转换而来的条件区间，而另一个区间则是 <code>MarkRange</code> 对应的数值区间。具体可以分为三个步骤：</p>
<ul>
<li>生成查询条件区间。将查询条件转换为条件区间，即便是单个值的查询条件也会被转换为区间的形式。</li>
<li>递归交集判断。以递归的形式依次对 <code>MarkRange</code> 的数值区间与条件区间做交集判断。<br>  假设从最大的区间 <code>[+A000, +inf)</code> 开始：<ul>
<li>如果不存在交集，则直接通过剪枝算法优化此段 <code>MarkRange</code>。</li>
<li>如果存在交集，且 <code>MarkRange</code> 步长大于 <code>8 * (end - start)</code> ，则将此区间进一步拆分为八个子区间（由 <code>merge_tree_coarse_index_granularity</code> 指定，默认值为 <code>8</code>），并重复此规则继续做递归交集判断。</li>
<li>如果存在交集，且 <code>MarkRange</code> 不可再分解（步长小于 <code>8</code>），则记录 <code>MarkRange</code> 并返回。</li>
</ul>
</li>
<li>合并 <code>MarkRange</code> 区间。将最终匹配的 <code>MarkRange</code> 聚在一起，合并他们的范围。</li>
</ul>
<p><img src="https://s2.loli.net/2022/08/08/ZxSk8mAEG31JaQf.png" alt="neo4j-3-6-1.jpg"></p>
<hr>

<h3 id="二级索引"><a href="#二级索引" class="headerlink" title="二级索引"></a>二级索引</h3><p>除了一级索引以外 <code>MergeTree</code> 同样支持二级索引。二级索引又称被为跳数索引，由数据的聚合信息构建而成，根据索引类型的不同，其聚合信息的内容也不同。当然跳数索引的目的也与一级索引一样都是为了帮助查询时减少数据扫描的范围。<br>跳数索引在默认情况下是关闭的，需要设置 <code>allow_experimental_data_skipping_indices</code> 才能使用：<code>SET allow_experimental_data_skipping_indices = 1</code>。<br><small>该参数在新版本中已经被取消。</small></p>
<p>另外跳数索引需要在 <code>CREATE</code> 语句内定义，支持使用元组和表达式的形式声明，其完整的定义语法如下所示：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">INDEX index_name expr TYPE index_type(...) GRANULARITY granularity</span><br></pre></td></tr></table></figure>
<p>与一级索引一样，如果在建表语句中声明跳数索引，则会额外生成相应的索引与标记文件（<code>skp_idx_[Column].idx</code> 和 <code>skp_idx_[Column].mrk</code>）。</p>
<h4 id="granularity-与-index-granularity-的关系"><a href="#granularity-与-index-granularity-的关系" class="headerlink" title="granularity 与 index_granularity 的关系"></a><code>granularity</code> 与 <code>index_granularity</code> 的关系</h4><p>不同的跳数索引之间除了拥有自身的参数之外，还拥有一个共同的参数就是 <code>granularity</code>。<br>对于跳数索引而言 <code>index_granularity</code> 定义数据的粒度，而 <code>granularity</code> 定义聚合信息汇总的粒度，即 <code>granularity</code> 定义一行跳数索引能够跳过多少个 <code>index_granularity</code> 区间的数据。</p>
<p>要解释 <code>granularity</code> 的作用，还要从跳数索引的数据生成规则说起，首先按照 <code>index_granularity</code> 粒度间隔将数据划分为 <code>n</code> 段，总共有 <code>[0, n-1]</code> 个区间，接着根据索引定义时声明的表达式，从 <code>0</code> 区间开始，依次按 <code>index_granularity</code> 粒度从数据中获取聚合信息，每次向前移动一步，聚合信息逐步累加，最后当移动 <code>granularity</code> 次区间时，则汇总并生成一行跳数索引数据。<br><img src="https://s2.loli.net/2022/08/08/MgqKXhi8ysPpxmn.png" alt="neo4j-3-7.png"></p>
<h4 id="跳数索引的类型"><a href="#跳数索引的类型" class="headerlink" title="跳数索引的类型"></a>跳数索引的类型</h4><p><code>MergeTree</code> 支持四种跳数索引，分别是 <code>minmax</code>、 <code>set</code>、 <code>ngrambf_v1</code> 和 <code>tokenbf_v1</code>。</p>
<ul>
<li><code>minmax</code>：记录了一段数据内的最小和最大值，其索引的作用类似分区目录的 <code>minmax</code> 索引，能够快速跳过无用的数据区间。  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">INDEX a ID TYPE minmax GRANULARITY 5</span><br></pre></td></tr></table></figure></li>
<li><code>set</code>：直接记录了声明字段或表达式的取值（唯一值，无重复），其完整形式为 <code>set(max_rows)</code>，其中 <code>max_rows</code> 是一个阈值，表示在一个 <code>index_granularity</code> 内，索引最多记录的数据行数。  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">INDEX b (length(ID) * 8) TYPE set(256) GRANULARITY 5</span><br></pre></td></tr></table></figure></li>
<li><code>ngrambf_v1</code>：记录的是数据短语的布隆表过滤器，只支持 <code>String</code> 和 <code>FixedString</code> 数据类型，<code>ngrambf_v1</code> 只能够提升 <code>in</code>、 <code>notIn</code>、 <code>like</code>、 <code>equals</code> 和 <code>notEquals</code> 查询的性能，其完整形式为 <code>ngrambf_v1(n, size_of_bloom_filter_in_bytes, number_of_hash_functions, random_seed)</code>。  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">INDEX c (ID, Code) TYPE ngrambf_v1(3, 256, 2, 0) GRANULARITY 5</span><br></pre></td></tr></table></figure></li>
<li><code>tokenbf_v1</code>：是 <code>ngrambf_v1</code> 的变种，同样是一种布隆过滤器索引，<code>tokenbf_v1</code> 除了短语 <code>token</code> 的处理方法外，其他与 <code>ngrambf_v1</code> 是完全一样的，<code>tokenbf_v1</code> 会自动按照非字符的、数字的字符串分割 <code>token</code>。  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">INDEX d ID TYPE tokenbf_v1(256, 2, 0) GRANULARITY 5</span><br></pre></td></tr></table></figure></li>
</ul>
<p><small>一张表支持声明多个跳数索引。</small></p>
<hr>

<h3 id="数据存储"><a href="#数据存储" class="headerlink" title="数据存储"></a>数据存储</h3><p>前面短暂提过在 <code>MergeTree</code> 中数据是按照列存储的，那么具体的存储细节、<code>MergeTree</code> 如何工作接下来就会说明。</p>
<h4 id="各列独立存储"><a href="#各列独立存储" class="headerlink" title="各列独立存储"></a>各列独立存储</h4><p>在 <code>MergeTree</code> 中，数据按列存储，而具体到每个列字段，数据也是独立存储的，每个列字段都有对应的 <code>.bin</code> 数据文件，承载着数据的物理存储。数据文件以分区目录的形式被存储，所以 <code>.bin</code> 数据文件只会保存当前分区片段内的这一部分数据。<br>按列独立存储的优势：</p>
<ul>
<li>更好地进行数据压缩（相同类型地数据放在一起，对压缩更友好）。</li>
<li>最小化数据扫描的范围。</li>
</ul>
<p><code>MergeTree</code> 并不是一股脑地将数据写入 <code>.bin</code> 数据文件，首先数据是经过压缩的，目前支持 <code>LZ4</code>、 <code>ZSTD</code>、 <code>Multiple</code> 和 <code>Delta</code> 几种算法，默认使用 <code>LZ4</code> 算法；其次数据会按照 <code>ORDER BY</code> 的声明排序；最后数据以压缩数据块的形式被组织写入 <code>.bin</code> 数据文件。</p>
<h4 id="压缩数据块"><a href="#压缩数据块" class="headerlink" title="压缩数据块"></a>压缩数据块</h4><p>一个压缩数据块由头信息和压缩数据两部分组成，头信息固定使用 <code>9</code> 位字节组成，具体由 <code>1</code> 个 <code>UInt8</code> （<code>1</code> 字节）整形和 <code>2</code> 个 <code>UInt32</code> （<code>4</code> 字节）整形组成，分别代表使用的用压缩算法类型、压缩后的数据大小和压缩前的数据大小。</p>
<p><code>.bin</code> 压缩文件是由多个压缩数据块组成的，而每个压缩数据块的头信息则基于 <code>CompressionMethod_CompressedSize_UncompressedSize</code> 公式生成的。<br>每个压缩数据块的体积按照其压缩前的数据字节大小被阉割控制在 <code>64KB ~ 1MB</code>，其上下限分别由 <code>min_compress_block_size</code> （默认 <code>65536</code>）和 <code>max_compress_block_size</code> （默认 <code>1048576</code>）参数指定。而一个压缩数据块的大小则是由 <code>index_granularity</code> 内数据的实际大小相关。</p>
<p><code>MergeTree</code> 在数据具体的写入过程中，会依照索引粒度（默认 <code>8192</code>），按批次获取数据并进行处理。如果把一批数据的未压缩大小设为 <code>size</code>，则整个写入过程遵循以下规则：</p>
<ul>
<li>单个批次数据 <code>size &lt; 64KB</code>：如果单个批次数据小于 <code>64KB</code>，则继续获取下一批次数据直到大于 <code>64KB</code>，然后生成一个数据压缩块。</li>
<li>单个批次数据 <code>64KB &lt;= size &lt;= 1MB</code>：如果单个批次数据大小刚好在 <code>64KB</code> 和 <code>1MB</code> 之间，则可以直接生成下一个数据压缩块。</li>
<li>单个批次数据 <code>size &gt; 1MB</code>：如果单个批次数据大于 <code>1MB</code>，则会截断 <code>1MB</code> 大小数据并生成一个压缩数据块，剩余数据继续依据上述规则执行。<br><img src="https://s2.loli.net/2022/08/09/X97lhzTVn6sdwWE.png" alt="neo4j-3-8.png"></li>
</ul>
<p>在 <code>.bin</code> 文件中引入压缩数据块的目的有以下两个：</p>
<ul>
<li>虽然数据被压缩后能够有效减少数据大小，降低存储空间并加属数据传输效率，但数据的压缩和解压动作，其本身也会带来额外的性能损耗。所以需要控制被压缩数据的大小，以求在性能损耗和压缩率之间寻求平衡。</li>
<li>在具体读取某一列数据时，首先需要将压缩数据加载到内存并解压，这样才能后续处理。通过压缩数据块，可以在步读取整个 <code>.bin</code> 文件的情况下将读取粒度降低到压缩数据块级别，从而缩小数据读取的范围。</li>
</ul>
<hr>

<h3 id="数据标记"><a href="#数据标记" class="headerlink" title="数据标记"></a>数据标记</h3><p>如果把 <code>MergeTree</code> 比作一本书，那么 <code>primary.idx</code> 一级索引就是这本书的目录，<code>.bin</code> 文件就是书中的内容，而 <code>.mrk</code> 文件则是一级章节目录和具体内容之间的关联。<br>主要记录以下两点重要信息：</p>
<ul>
<li>一级章节对应的页码信息。</li>
<li>一段文字内容在某一页中的起始位置信息。</li>
</ul>
<h4 id="数据标记的生成规则"><a href="#数据标记的生成规则" class="headerlink" title="数据标记的生成规则"></a>数据标记的生成规则</h4><p>数据标记作为衔接一级索引与数据之间的桥梁，类似于书签，且书中的每一个章节都有自己的书签。<br><img src="https://s2.loli.net/2022/08/23/dM58XwQJVgL6o1Z.png" alt="neo4j-3-9.png"></p>
<p>在上述中可以发现数据标记的首个特征即数据标记和索引区间是对齐的，均按照 <code>index_granularity</code> 的粒度间隔，如此一来只需简单通过索引区间的下标编号即可找到对应的数据标记。<br>为了能够与数据衔接，数据标记文件也与 <code>.bin</code> 文件一一对应，即每一个列字段 <code>[Column].bin</code> 文件都有一个与之对应的 <code>[Column].mrk</code> 数据标记文件，用于记录数据在 <code>.bin</code> 文件中的偏移量信息。<br>一行标记数据使用一个元组表示，元组内包含两个整形数值的偏移量信息，他们分别表示在此段数据区间内，在对应的 <code>.bin</code> 压缩文件中压缩数据块的起始偏移量；以及将该数据压缩块解压后，其未压缩数据的起始偏移量。</p>
<p>每一行标记数据都表示一个片段的数据在 <code>.bin</code> 压缩文件中的位置信息。标记数据与一级索引数据不同，并不能常驻内存，而是使用 <code>LRU</code> 缓存策略加快其取用速度。</p>
<h4 id="数据标记的工作方式"><a href="#数据标记的工作方式" class="headerlink" title="数据标记的工作方式"></a>数据标记的工作方式</h4><p><code>MergeTree</code> 在读取数据时必须通过标记数据的位置信息才能找到所需要的数据，整个查找过程大致可以分为<strong>读取压缩数据块</strong>和<strong>读取数据</strong>两个步骤。</p>
<ul>
<li>读取压缩数据块，在查询某一列数据时，<code>MergeTree</code> 无需一次性加载全部 <code>.bin</code> 文件，而是可以根据需要，只加载特定的压缩数据块。</li>
<li>读取数据，在读取解压后的数据时，<code>MergeTree</code> 并不需要一次性扫描全部解压数据，而是可以根据需要以 <code>index_granularity</code> 的粒度加载特定的一小段，而为了实现这一特性需要借助标记文件中保存的解压数据块中的偏移量。</li>
</ul>
<hr>

<h3 id="协同总结"><a href="#协同总结" class="headerlink" title="协同总结"></a>协同总结</h3><p>在说明上述的特性后，下面按照写入过程、查询过程以及数据标记和压缩数据块的三种对应关系的角度来说一说。</p>
<h4 id="写入过程"><a href="#写入过程" class="headerlink" title="写入过程"></a>写入过程</h4><p>数据写入的第一步就是生成分区目录，伴随着每一批数据的写入，都会生成一个新的分区目录。而在后续的某一时刻，属于相同分区的目录会按照规则继续合并。接下来会按照 <code>index_granularity</code> 索引粒度，会分别生成 <code>primary.idx</code> 一级索引、列字段 <code>.mrk</code> 数据标记和 <code>.bin</code> 数据压缩文件。<br>其中索引与标记都是一一对应的，而标记与数据压缩块则是根据区间数据的大小会生成多对一、一对一、一对多三种关系。</p>
<h4 id="查询过程"><a href="#查询过程" class="headerlink" title="查询过程"></a>查询过程</h4><p>数据查询的本质就是一个不断缩小数据范围的过程，在理想的情况下，<code>MergeTree</code> 借助分区索引、一级索引、二级索引，将数据扫描到最小，然后借助数据标记，将需要解压与计算的数据范围缩至最小。<br>当然最坏的情况就是查询语句没有匹配到任何的索引，那么在后续的数据扫描中，会扫描所有的分区目录，以及目录内索引段的最大区间，当然在此虽然不能减少数据扫描范围，不过以及可以借助数据标记，同时以多线程的方式同时读取多个压缩块以提升性能。</p>
<h4 id="数据标记与压缩数据块之间对应关系"><a href="#数据标记与压缩数据块之间对应关系" class="headerlink" title="数据标记与压缩数据块之间对应关系"></a>数据标记与压缩数据块之间对应关系</h4><p>由于数据压缩块的划分与一个间隔 <code>index_granularity</code> 内的数据大小有关，每个数据压缩块的体积被限制在 <code>64KB~1MB</code> 之间，同时一个间隔内的数据又只会产生一行数据标记，那么根据一个间隔内的数据的实际字节大小，数据标记和压缩数据块之间产生了不同的三种关系。</p>
<ul>
<li>多对一，即多个数据标记对应一个数据压缩块。当一个间隔内的数据未压缩大小小于 <code>64KB</code>，则会出现这种情况。</li>
<li>一对一，即一个数据标记对应一个数据压缩块。当一个间隔内的数据未压缩大小刚好大于等于 <code>64KB</code> 且小于 <code>1MB</code>，则会出现这种情况。</li>
<li>一对多，即一个数据标记对应多个数据压缩块。当一个间隔内的数据未压缩大小直接大于 <code>1MB</code>，则会出现这种情况。</li>
</ul>
<hr>

<h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><hr>

<h3 id="个人备注"><a href="#个人备注" class="headerlink" title="个人备注"></a>个人备注</h3><p><strong>此博客内容均为作者学习所做笔记，侵删！</strong><br><strong>若转作其他用途，请注明来源！</strong></p>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/ClickHouse/" rel="tag"># ClickHouse</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/SpringBoot%E9%9B%86%E6%88%90Prometheus-%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8C%87%E6%A0%87/" rel="prev" title="SpringBoot集成Prometheus-自定义指标">
      <i class="fa fa-chevron-left"></i> SpringBoot集成Prometheus-自定义指标
    </a></div>
      <div class="post-nav-item">
    <a href="/ClickHouse-%E5%88%86%E5%B8%83%E5%BC%8F/" rel="next" title="ClickHouse-分布式">
      ClickHouse-分布式 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          
    <div class="comments" id="gitalk-container"></div>

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BC%95%E5%85%A5"><span class="nav-number">1.</span> <span class="nav-text">引入</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E6%96%B9%E5%BC%8F"><span class="nav-number">2.</span> <span class="nav-text">创建方式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84"><span class="nav-number">3.</span> <span class="nav-text">存储结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E5%88%86%E5%8C%BA"><span class="nav-number">4.</span> <span class="nav-text">数据分区</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%86%E5%8C%BA%E8%A7%84%E5%88%99"><span class="nav-number">4.1.</span> <span class="nav-text">分区规则</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%86%E5%8C%BA%E7%9B%AE%E5%BD%95%E7%9A%84%E5%91%BD%E5%90%8D%E8%A7%84%E5%88%99"><span class="nav-number">4.2.</span> <span class="nav-text">分区目录的命名规则</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%86%E5%8C%BA%E7%9B%AE%E5%BD%95%E7%9A%84%E5%90%88%E5%B9%B6%E8%BF%87%E7%A8%8B"><span class="nav-number">4.3.</span> <span class="nav-text">分区目录的合并过程</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%80%E7%BA%A7%E7%B4%A2%E5%BC%95"><span class="nav-number">5.</span> <span class="nav-text">一级索引</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%A8%80%E7%96%8F%E7%B4%A2%E5%BC%95"><span class="nav-number">5.1.</span> <span class="nav-text">稀疏索引</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%B4%A2%E5%BC%95%E7%B2%92%E5%BA%A6"><span class="nav-number">5.2.</span> <span class="nav-text">索引粒度</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%B4%A2%E5%BC%95%E6%95%B0%E6%8D%AE%E7%9A%84%E7%94%9F%E6%88%90%E8%A7%84%E5%88%99"><span class="nav-number">5.3.</span> <span class="nav-text">索引数据的生成规则</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%B4%A2%E5%BC%95%E7%9A%84%E6%9F%A5%E8%AF%A2%E8%BF%87%E7%A8%8B"><span class="nav-number">5.4.</span> <span class="nav-text">索引的查询过程</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%8C%E7%BA%A7%E7%B4%A2%E5%BC%95"><span class="nav-number">6.</span> <span class="nav-text">二级索引</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#granularity-%E4%B8%8E-index-granularity-%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="nav-number">6.1.</span> <span class="nav-text">granularity 与 index_granularity 的关系</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%B7%B3%E6%95%B0%E7%B4%A2%E5%BC%95%E7%9A%84%E7%B1%BB%E5%9E%8B"><span class="nav-number">6.2.</span> <span class="nav-text">跳数索引的类型</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8"><span class="nav-number">7.</span> <span class="nav-text">数据存储</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%90%84%E5%88%97%E7%8B%AC%E7%AB%8B%E5%AD%98%E5%82%A8"><span class="nav-number">7.1.</span> <span class="nav-text">各列独立存储</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8E%8B%E7%BC%A9%E6%95%B0%E6%8D%AE%E5%9D%97"><span class="nav-number">7.2.</span> <span class="nav-text">压缩数据块</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E6%A0%87%E8%AE%B0"><span class="nav-number">8.</span> <span class="nav-text">数据标记</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E6%A0%87%E8%AE%B0%E7%9A%84%E7%94%9F%E6%88%90%E8%A7%84%E5%88%99"><span class="nav-number">8.1.</span> <span class="nav-text">数据标记的生成规则</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E6%A0%87%E8%AE%B0%E7%9A%84%E5%B7%A5%E4%BD%9C%E6%96%B9%E5%BC%8F"><span class="nav-number">8.2.</span> <span class="nav-text">数据标记的工作方式</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8D%8F%E5%90%8C%E6%80%BB%E7%BB%93"><span class="nav-number">9.</span> <span class="nav-text">协同总结</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%86%99%E5%85%A5%E8%BF%87%E7%A8%8B"><span class="nav-number">9.1.</span> <span class="nav-text">写入过程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9F%A5%E8%AF%A2%E8%BF%87%E7%A8%8B"><span class="nav-number">9.2.</span> <span class="nav-text">查询过程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E6%A0%87%E8%AE%B0%E4%B8%8E%E5%8E%8B%E7%BC%A9%E6%95%B0%E6%8D%AE%E5%9D%97%E4%B9%8B%E9%97%B4%E5%AF%B9%E5%BA%94%E5%85%B3%E7%B3%BB"><span class="nav-number">9.3.</span> <span class="nav-text">数据标记与压缩数据块之间对应关系</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BC%95%E7%94%A8"><span class="nav-number">10.</span> <span class="nav-text">引用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%AA%E4%BA%BA%E5%A4%87%E6%B3%A8"><span class="nav-number">11.</span> <span class="nav-text">个人备注</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="vgbhfive"
      src="https://i.loli.net/2019/12/10/JF3dKDSkZoPz7h6.jpg">
  <p class="site-author-name" itemprop="name">vgbhfive</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">141</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">48</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/vgbhfive" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;vgbhfive" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:vgbhfive@foxmail.com" title="E-Mail → mailto:vgbhfive@foxmail.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://vgbhfive.com/" title="Web-Site → https:&#x2F;&#x2F;vgbhfive.com" rel="noopener" target="_blank"><i class="fab fa-chrome fa-fw"></i>Web-Site</a>
      </span>
  </div>



      </div>
        <div class="back-to-top motion-element">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        
  <div class="beian"><a href="https://beian.miit.gov.cn/" rel="noopener" target="_blank">陕ICP备20002937号-1 </a>
  </div>

<div class="copyright">
  
  &copy; 2016 – 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">vgbhfive</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a>
  </div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="Total Visitors">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="Total Views">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

  

<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.css">

<script>
NexT.utils.loadComments(document.querySelector('#gitalk-container'), () => {
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js', () => {
    var gitalk = new Gitalk({
      clientID    : '2ff0dea213e4c7c0bbcc',
      clientSecret: '7f3d808240b513b00a1dbf20d725809acc316b67',
      repo        : 'vgbhfive.github.io',
      owner       : 'vgbhfive',
      admin       : ['vgbhfive'],
      id          : 'f30e0d2d4e3b35219272b5bc6c8c4b3e',
        language: 'zh-CN',
      distractionFreeMode: true
    });
    gitalk.render('gitalk-container');
  }, window.Gitalk);
});
</script>

</body>
</html>
