<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="https://i.loli.net/2019/12/10/JF3dKDSkZoPz7h6.jpg">
  <link rel="icon" type="image/png" sizes="16x16" href="https://i.loli.net/2019/12/10/JF3dKDSkZoPz7h6.jpg">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">
  <meta name="google-site-verification" content="G-QBK8PCQC9B">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"blog.vgbhfive.cn","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":true,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":"gitalk","storage":true,"lazyload":false,"nav":null,"activeClass":"gitalk"},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="概述随着业务线数据量的突飞猛进、服务器的意外宕机，这些都是底层基础服务会遇到的问题，因此 ClickHouse 就设计了集群、副本和分片这三个帮手来帮忙。">
<meta property="og:type" content="article">
<meta property="og:title" content="ClickHouse-分布式">
<meta property="og:url" content="https://blog.vgbhfive.cn/ClickHouse-%E5%88%86%E5%B8%83%E5%BC%8F/index.html">
<meta property="og:site_name" content="Vgbhfive&#39;s Blog">
<meta property="og:description" content="概述随着业务线数据量的突飞猛进、服务器的意外宕机，这些都是底层基础服务会遇到的问题，因此 ClickHouse 就设计了集群、副本和分片这三个帮手来帮忙。">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://s2.loli.net/2022/09/10/xETJYlW2Ic4dft3.png">
<meta property="article:published_time" content="2022-09-10T12:18:11.000Z">
<meta property="article:modified_time" content="2023-01-01T15:46:36.000Z">
<meta property="article:author" content="vgbhfive">
<meta property="article:tag" content="ClickHouse">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://s2.loli.net/2022/09/10/xETJYlW2Ic4dft3.png">

<link rel="canonical" href="https://blog.vgbhfive.cn/ClickHouse-%E5%88%86%E5%B8%83%E5%BC%8F/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'en'
  };
</script>

  <title>ClickHouse-分布式 | Vgbhfive's Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<link rel="alternate" href="/atom.xml" title="Vgbhfive's Blog" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Vgbhfive's Blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>About</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-pictures">

    <a href="/pictures/" rel="section"><i class="fa fa-th fa-fw"></i>Pictures</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
        <li class="menu-item menu-item-sitemap">

    <a href="/sitemap.xml" rel="section"><i class="fa fa-sitemap fa-fw"></i>Sitemap</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="reading-progress-bar"></div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://blog.vgbhfive.cn/ClickHouse-%E5%88%86%E5%B8%83%E5%BC%8F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://i.loli.net/2019/12/10/JF3dKDSkZoPz7h6.jpg">
      <meta itemprop="name" content="vgbhfive">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Vgbhfive's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          ClickHouse-分布式
        </h1>

        <div class="post-meta">
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-09-10 20:18:11" itemprop="dateCreated datePublished" datetime="2022-09-10T20:18:11+08:00">2022-09-10</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2023-01-01 23:46:36" itemprop="dateModified" datetime="2023-01-01T23:46:36+08:00">2023-01-01</time>
              </span>

          
            <span class="post-meta-item" title="Views" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">Views: </span>
              <span id="busuanzi_value_page_pv"></span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>随着业务线数据量的突飞猛进、服务器的意外宕机，这些都是底层基础服务会遇到的问题，因此 <code>ClickHouse</code> 就设计了<strong>集群</strong>、<strong>副本</strong>和<strong>分片</strong>这三个帮手来帮忙。</p>
<span id="more"></span>

<p>集群是副本和分片的基础，他将 <code>ClickHouse</code>. 的服务拓扑由单节点延伸为多节点，但是他又不像 <code>hadoop</code> 那样的系统，要求所有的节点都组成一个大集群。<code>ClickHouse</code> 的集群配置非常灵活，用户既可以将所有节点组成一个大集群，也可以按照业务的诉求将节点划分为多个小集群。<br>在每个小集群区域之间，他们的节点、分区和副本数量可以各不相同。从总体来看，集群定义了多个节点的拓扑关系，这些节点在后续服务中会相互合作，而执行层面的具体内容则是由副本和分片来执行。</p>
<p>那么如何区分副本和分片呢？<br>在数据层面上，副本之间的数据完全相同，而分片之间数据是不同的。在功能层面上，副本的作用在于防止数据丢失，增加存储数据的冗余，而分片的目的在于实现数据的水平切分。</p>
<hr>

<h3 id="副本"><a href="#副本" class="headerlink" title="副本"></a>副本</h3><p>之前有说过 <code>ReplicatedMergeTree</code> 复制表引擎，该引擎可以实现应用副本的能力，他是在 <code>MergeTree</code> 表引擎的基础上实现了分布式协同的能力。<br>在 <code>MergeTree</code> 中，一个数据分区从开始创建到全部完成，会经历两类存储区域：</p>
<ul>
<li>内存，数据首先会被写入到内存缓冲区。</li>
<li>本地磁盘，数据接着会被写入 <code>tmp</code> 临时目录分区，待全部完成后再将临时目录重命名为正式分区。</li>
</ul>
<p>而 <code>ReplicatedMergeTree</code> 在上述的基础上增加了 <code>ZooKeeper</code> 的部分，他会进一步在 <code>ZooKeeper</code> 内部创建一系列的监听节点，并以此实现多个实例之间的通信，并且在整个通信过程中，<code>ZooKeeper</code> 不会涉及到任何的数据传输。</p>
<p>那么我们总结下副本的特点：</p>
<ul>
<li>依赖 <code>ZooKeeper</code>，在执行 <code>insert</code> 和 <code>alter</code> 查询时 <code>ReplicatedMergeTree</code> 需要借助 <code>ZooKeeper</code> 的分布式协同能力，以实现多个副本之间的同步，但是在 <code>select</code> 副本时并不需要使用。</li>
<li>表级别的副本，副本是在表级别定义的，所以每张表的副本配置都可以按照他的实际需求进行个性化定义，包括副本的数量、副本在集群中的分布位置等。</li>
<li>多主架构，可以在任意一个副本上执行 <code>insert</code> 和 <code>alter</code> 查询，他们的效果都是相同的。</li>
<li><code>Block</code> 数据块，在执行 <code>insert</code> 命令时，会依据 <code>max_insert_block_size</code> 的大小将数据切分为若干个 <code>Block</code> 数据块，因此 <code>Block</code> 数据块是写入的基本单元，并且具有写入的唯一性和原子行。</li>
<li>原子性，在数据写入时，一个 <code>Block</code> 块内的数据要么全部写入成功，要么全部失败。</li>
<li>唯一性，在写入一个 <code>Block</code> 数据块时，会按照当前 <code>Block</code> 数据块的数据顺序、数据行和数据大小等指标计算 <code>Hash</code> 信息摘要并记录在案。如果后续遇到相同的 <code>Hash</code> 摘要则该数据块会被忽略。</li>
</ul>
<h4 id="ZooKeeper-配置方式"><a href="#ZooKeeper-配置方式" class="headerlink" title="ZooKeeper 配置方式"></a><code>ZooKeeper</code> 配置方式</h4><p>首先新建一个 <code>metrika.xml</code> 的配置文件内容如下：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">yandex</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">zookeeper-servers</span>&gt;</span> <span class="comment">&lt;!-- ZooKeeper 配置，名称自定义 --&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">node</span> <span class="attr">index</span>=<span class="string">&quot;1&quot;</span>&gt;</span> <span class="comment">&lt;!-- 节点配置，可以配置多个地址 --&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">host</span>&gt;</span>host1.vgbhfive.cn<span class="tag">&lt;/<span class="name">host</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">port</span>&gt;</span>2181<span class="tag">&lt;/<span class="name">port</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">node</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">zookeeper-servers</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">yandex</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>接着在全局配置 <code>config.xml</code> 中使用 <code>&lt;include_from&gt;</code> 标签导入刚才定义的配置：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">include_from</span>&gt;</span>/etc/clickhouse-server/cpnfig.d/metrika.xml<span class="tag">&lt;/<span class="name">include_from</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><small><code>incl</code> 与 <code>metrika.xml</code> 配置文件中的节点名称彼此要相互对应。</small></p>
<p>另外 <code>ClickHouse</code> 还在系统表中提供了一张 <code>zookeeper</code> 的代理表，通过这个表可以使用 <code>SQL</code> 查询读取远端 <code>ZooKeeper</code> 内的数据，不过查询时需要指定 <code>path</code> 条件才能查询到数据。</p>
<h4 id="副本定义形式"><a href="#副本定义形式" class="headerlink" title="副本定义形式"></a>副本定义形式</h4><p>首先由于增加了数据的冗余存储，所以降低了数据丢失的风险；其次由于副本采用多主架构，所以每个副本实例都可以作为数据读、写的入口，但这都增加了节点的负载。</p>
<p><code>ReplicatedMergeTree</code> 定义方式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ENGINE = ReplicatedMergeTree(&#x27;zk_path&#x27;, &#x27;replica_name&#x27;)</span><br></pre></td></tr></table></figure>
<p> 在上述配置中有 <code>zk_path</code> 和 <code>replica_name</code> 两项配置：</p>
<ul>
<li><code>zk_path</code> 用于指定在 <code>ZooKeeper</code> 中创建的数据表的路径，路径名称是自定义的，可以设置成自己希望的任何路径。<br>当然也有一些约定俗成的配置：<ul>
<li><code>/clickhouse/tables/</code> 是约定的路径固定前缀，表示存放数据表的根路径。</li>
<li><code>&#123;shard&#125;</code> 表示分片编号，通常使用数字来替代。</li>
<li><code>table_name</code> 表示数据表的名称，为了维护方便通常采用与物理表相同的名字。</li>
</ul>
</li>
<li><code>replica_name</code> 是定义副本名称，该名称是区分不同副本实例的唯一标识。</li>
</ul>
<p><small>对于 <code>zk_path</code> 而言，同一张数据表的同一个分片的不同副本，应该定义相同的路径。而对于 <code>replica_name</code> 而言，同一张数据表的同一个分片的不同副本，应该定义不同的名称。</small></p>
<h4 id="ReplicatedMergeTree-原理解析"><a href="#ReplicatedMergeTree-原理解析" class="headerlink" title="ReplicatedMergeTree 原理解析"></a><code>ReplicatedMergeTree</code> 原理解析</h4><p>在 <code>ReplicatedMergeTree</code> 的核心逻辑中，大量运用了 <code>ZooKeeper</code> 的能力，以实现多个 <code>ReplicatedMergeTree</code> 副本实例之间的协同，包括主副本选举、副本状态感知、操作日志分发、任务队列和 <code>BlockID</code> 去重判断等。<br>在执行 <code>INSERT</code> 数据写入、<code>MERGE</code> 分区和 <code>MUTATION</code> 操作的时候都会涉及到 <code>ZooKeeper</code> 的通信，但是在通信的过程中，并不会涉及到任何表数据的传输，在查询数据时也不会访问 <code>ZooKeeper</code>。</p>
<h5 id="ZooKeeper-节点结构"><a href="#ZooKeeper-节点结构" class="headerlink" title="ZooKeeper 节点结构"></a><code>ZooKeeper</code> 节点结构</h5><p><code>ReplicatedMergeTree</code> 依赖 <code>ZooKeeper</code> 的事件监听机制以实现各个副本之间的协同。因此在每个 <code>ReplicatedMergeTree</code> 表的创建过程中，会以 <code>zk_path</code> 为根路径创建一组监听节点，按照作用不同，监听节点可以大致分为一下几点：</p>
<ul>
<li>元数据<ul>
<li><code>/metadata</code> 保存元数据信息，包括主键、分区键、采样表达式等。</li>
<li><code>/columns</code> 保存列字段信息，包括列名称和数据类型。</li>
<li><code>/replicas</code> 保存副本名称，对应设置参数中的 <code>replica_name</code>。</li>
</ul>
</li>
<li>判断标识<ul>
<li><code>/leader_election</code> 用于主副本的选举工作，主副本会主导 <code>MERGE</code> 和 <code>MUTATION</code> 操作，这些任务都是在主副本完成之后再借助 <code>ZooKeeper</code> 将消息事件分发到其他副本。</li>
<li><code>/blocks</code> 记录 <code>Block</code> 数据块的 <code>Hash</code> 信息摘要，以及对应的 <code>partition_id</code>。通过 <code>Hash</code> 摘要能够判断 <code>Block</code> 数据块是否重复；通过 <code>partition_id</code> 则能找到需要同步的数据分区。</li>
<li><code>block_numbers</code> 按照分区的写入顺序，以相同的顺序记录 <code>partition_id</code>，各个副本在本地进行 <code>MERGE</code> 时都会依照相同的 <code>block_numbers</code> 顺序进行。</li>
<li><code>quorum</code> 记录 <code>quorum</code> 的数量，当至少有 <code>quorum</code> 数量的副本写入成功后，整个写入操作才算成功。<code>quorum</code> 的数量有 <code>insert_quorum</code> 参数控制，默认值为 <code>0</code>。</li>
</ul>
</li>
<li>操作日志<ul>
<li><code>/log</code> 常规操作日志，保存副本需要执行的任务指令。</li>
<li><code>/mutations</code> 操作日志，作用与 <code>/log</code> 日志类似，当执行 <code>ALERT DELETE</code> 或 <code>ALERT UPDATE</code> 查询时，操作指令会被添加到这个节点。</li>
<li><code>/replicas/&#123;replica_name&#125;/*</code> 每个副本各自的节点下的一组监听节点，用于指导副本在本地执行具体的任务指令<ul>
<li><code>/queue</code> 任务队列节点，用于执行具体的操作任务。</li>
<li><code>/log_pointer</code> <code>log</code> 日志指针节点，记录最后一次执行的 <code>log</code> 日志下标信息。</li>
<li><code>/mutation_pointer</code> <code>mutations</code> 日志指针节点，记录了最后一次执行的 <code>mutatutions</code> 日志名称。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h5 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h5><p><code>/log</code> 和 <code>/mutations</code> 他们犹如通信路由器，是分发操作指令的信息通道，而发送指令的方式则是为这些父节点添加子节点。所有的副本实例都会监听父节点的变化，当有子节点被添加时都会被其他副本实时感知。</p>
<p>被添加的子节点统一被抽象为 <code>Entry</code> 对象，而具体实现则是 <code>LogEntry</code> 和 <code>MutationEntry</code> 对象承载，分别对应 <code>/log</code> 和 <code>/mutations</code> 节点：</p>
<ul>
<li><code>LogEntry</code> 用于封装 <code>/log</code> 子节点信息，核心属性如下：<ul>
<li><code>source replica</code> 发送这条 <code>Log</code> 指令的副本来源，对应 <code>replica_name</code>。</li>
<li><code>type</code> 操作指令类型，主要有 <code>get</code>、 <code>merge</code> 和 <code>mutate</code> 三种，分别对应从远程副本下载分区、合并分区和 <code>MUTATION</code> 操作。</li>
<li><code>block_id</code> 当前分区的 <code>BlockID</code>，对应 <code>/blocks</code> 路径下子节点的名称。</li>
<li><code>partition_name</code> 当前分区目录的名称。</li>
</ul>
</li>
<li><code>MutationEntry</code>用于封装 <code>/mutations</code> 子节点信息，核心属性如下：<ul>
<li><code>source replica</code> 发送这条 <code>MUTATION</code> 指令的副本来源，对应 <code>replica_name</code>。</li>
<li><code>commands</code> 操作指令，主要有 <code>ALERT DELETE</code> 和 <code>ALERT UPDATE</code>。</li>
<li><code>mutation_id</code> <code>MUTATION</code> 操作的版本号。</li>
<li><code>partition_id</code> 当权分区目录的 <code>ID</code>。</li>
</ul>
</li>
</ul>
<h5 id="副本协同流程"><a href="#副本协同流程" class="headerlink" title="副本协同流程"></a>副本协同流程</h5><h6 id="写入执行流程"><a href="#写入执行流程" class="headerlink" title="写入执行流程"></a>写入执行流程</h6><p>当需要在 <code>ReplicatedMergeTree</code> 中执行 <code>INSERT</code> 查询以写入数据时，即会进入 <code>INSERT</code> 核心流程，整体流程从上至下按照时间顺序进行，大致可以分为八个步骤。</p>
<ol>
<li><p>创建第一个副本实例</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> replica_sales_1 &#123;</span><br><span class="line">    id String,</span><br><span class="line">    price Float64,</span><br><span class="line">    create_time DateTime</span><br><span class="line">&#125; ENGINW <span class="operator">=</span> ReplicatedMergeTree(<span class="string">&#x27;/clickhouse/tables/01/replicated_sales_1&#x27;</span>, <span class="string">&#x27;ch5.vgbhfive.cn&#x27;</span>)</span><br><span class="line"><span class="keyword">PARTITION</span> <span class="keyword">BY</span> toYYYYMM(create_time)</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> id</span><br></pre></td></tr></table></figure>
<p>在创建的过程中 <code>ReplicatedMergeTree</code> 会进行一些初始化操作：</p>
<ul>
<li>根据 <code>zk_path</code> 初始化所有的 <code>ZooKeeper</code> 节点。</li>
<li>在 <code>/replicas/</code> 节点下注册自己的副本实例 <code>ch5.vgbhfive.cn</code>。</li>
<li>启动监听任务，监听 <code>/log</code> 日志节点。</li>
<li>参与副本选举，选举出主副本，选举的方式是向 <code>/leader_election/</code> 插入子节点，第一个插入成功的副本就是主副本。</li>
</ul>
</li>
<li><p>创建第二个副本实例<br>与上述第一个创建副本实例类似，不同之处在于实例名称。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> replica_sales_1 &#123;</span><br><span class="line">    id String,</span><br><span class="line">    price Float64,</span><br><span class="line">    create_time DateTime</span><br><span class="line">&#125; ENGINW <span class="operator">=</span> ReplicatedMergeTree(<span class="string">&#x27;/clickhouse/tables/01/replicated_sales_1&#x27;</span>, <span class="string">&#x27;ch6.vgbhfive.cn&#x27;</span>)</span><br><span class="line"><span class="keyword">PARTITION</span> <span class="keyword">BY</span> toYYYYMM(create_time)</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> id</span><br></pre></td></tr></table></figure>
<p>在创建过程中，第二个 <code>ReplicatedMergeTree</code> 同样会进行一些初始化操作：</p>
<ul>
<li>在 <code>/replicas/</code> 节点下注册自己的副本实例 <code>ch6.vgbhfive.cn</code>。</li>
<li>启动监听任务，监听 <code>/log</code> 日志节点。</li>
<li>参数副本选举，选举出主副本。</li>
</ul>
</li>
<li><p>向第一个实例中写入数据<br>现在尝试向第一个副本 <code>ch5</code> 写入数据：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">INSERT INTO TABLE replicated_sales_1 VALUES(&#x27;A001&#x27;, 100, &#x27;2022-05-15 00:00:00&#x27;)</span><br></pre></td></tr></table></figure>
<p>上述命令执行完毕后，首先会在本地完成分区目录的写入：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Renaming temporary part tmp_insert_202205_1_1_0 to 202205_0_0_0</span><br></pre></td></tr></table></figure>
<p>接着向 <code>/blocks</code> 节点写入该数据分区的 <code>block_id</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Wrote block with ID &#x27;202205_xxxxx_yyyy&#x27;</span><br></pre></td></tr></table></figure>
<p>该 <code>block_id</code> 将作为后续去重操作的判断依据。如果此时再重复执行刚才的语句，试图写入重复数据，则会抛出异常，即副本会自动忽略 <code>block_id</code> 重复的待写入数据。<br>此外如果设置了 <code>insert_quorum</code> （默认参数为 <code>0</code>），并且 <code>insert_quorum &gt;= 2</code>，则 <code>ch5  </code> 会进一步监控已完成写入操作的副本个数，只有当写入副本个数大于或等于 <code>insert_quorum</code> 时，整个写入操作才会成功。</p>
</li>
<li><p>由第一个副本实例推送 <code>Log</code> 日志<br>在 <code>3</code> 步骤完成之后，会继续执行 <code>insert</code> 的副本向 <code>/log</code> 节点推送操作日志。日志的编号是 <code>/log/log-00000000</code>，而 <code>LogEntry</code> 的核心属性如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">/log/log-00000000</span><br><span class="line">source replica: ch5.vgbhfive.cn</span><br><span class="line">block_id: 202205_xxxxx</span><br><span class="line">type: get</span><br><span class="line">partition_name: 202205_0_0_0</span><br></pre></td></tr></table></figure>
<p>从日志内容中可以看出，操作类型为 <code>get</code> 下载，而需要下载的分区时 <code>202205_0_0_0</code>。其余所有副本都会基于 <code>Log</code> 日志以相同的顺序执行命令。</p>
</li>
<li><p>第二个副本实例拉取 <code>Log</code> 日志<br><code>ch6</code> 副本会一直监听 <code>/log</code> 节点变化，当 <code>ch5</code> 推送日志之后，<code>ch6</code>  便会触发日志的拉取任务并更新 <code>log_pointer</code>，将其指向最新日志下标：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/replicas/ch6.vgbhfive.cn/log_pointer: 0</span><br></pre></td></tr></table></figure>
<p>在拉取 <code>LogEntry</code> 之后，并不会直接执行，而是将其转为任务对象放至队列：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/replicas/ch6.vgbhfive.cn/queues/</span><br><span class="line">Pulling 1 entries to queue: log-00000000 to log-00000000</span><br></pre></td></tr></table></figure>
<p><small>上述 <code>LogEntry</code> 放入队列是因为在复杂的情况下，会连续收到许多个 <code>LogEntry  </code> ，所以使用队列消化任务也是一种合理的设计。</small></p>
</li>
<li><p>第二个副本实例向其他副本发起下载请求<br><code>ch6</code> 基于 <code>/queue</code> 队列开始执行任务，当看到 <code>type</code> 为 <code>get</code>    时，<code>ReplicatedMergeTree</code> 会明白此时在远端的其他副本已经成功写入数据分区，而自己需要同步这些数据。<br><code>ch6</code> 上的第二个副本实例会开始选择一个远端的其他副本作为数据的下载来源。远端副本的选择算法大致是这样的：</p>
<ul>
<li>从 <code>/replicas</code> 节点拿到所有的副本节点。</li>
<li>遍历这些副本选取其中一个。选取的副本需要拥有最大的 <code>log_pointer</code> 下标，并且 <code>/queue</code> 子节点数量最少。<code>log_pointer</code> 下标最大，则意味该副本执行的日志最多，数据应该更加完整；而 <code>/queue</code> 最小，则意味着该副本目前的任务执行负担最小。</li>
</ul>
<p> <small>在这个实例中，算法选择的副本实例是 <code>ch5</code>。</small></p>
</li>
<li><p>第一个副本实例响应数据下载<br><code>ch5</code> 的 <code>DataPartsExchange</code> 端口服务接收到调用请求，在得知对方来意之后，根据参数做出响应，将本地分区 <code>202205_0_0_0</code> 基于 <code>DataPartsExchange</code> 的服务响应发送回 <code>ch6</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Sending part 202205_0_0_0</span><br></pre></td></tr></table></figure>
</li>
<li><p>第二个实例下载数据并完成本地写入<br><code>ch6</code> 副本在接收到 <code>ch5</code> 的分区数据后，首先将其写入到临时目录中：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tmp_fetch_202205_0_0_0</span><br></pre></td></tr></table></figure>
<p>待全部数据接收完成之后，重命名该目录：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Renaming temporary part tmp_fetch_202205_0_0_0 to 202205_0_0_0</span><br></pre></td></tr></table></figure>
<p>至此，整个写入结束。</p>
</li>
</ol>
<p>在整个 <code>insert</code> 的写入过程中，<code>ZooKeeper</code> 不会进行任何实质性的数据传输。本着谁执行谁负责的原则，由写入数据的实例负责发送 <code>Log</code> 日志、通知其他实例、监控是否完成、返回下载数据。</p>
<h6 id="MERGE-执行流程"><a href="#MERGE-执行流程" class="headerlink" title="MERGE 执行流程"></a><code>MERGE</code> 执行流程</h6><p>当需要在 <code>ReplicatedMergeTree</code> 中触发分区合并动作时，即会进入这个部分的流程，无论 <code>MERGE</code> 操作从哪个副本发起，其合并计划都会交由主副本来制定。</p>
<ol>
<li><p>创建远程连接，尝试与主副本通信。<br>首先在 <code>ch6</code> 节点执行 <code>OPTIMIZE</code> 强制执行 <code>MERGE</code> 合并，此时 <code>ch6</code> 通过 <code>replicas</code> 找到主副本 <code>ch5</code>，并尝试建立与它的远程连接。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">optimize table replicated_sales_1</span><br><span class="line">Connection (ch5.vgbhfive.cn:9000): Connecting. Database: default. User: default</span><br></pre></td></tr></table></figure>
</li>
<li><p>主副本接收通信<br>主副本 <code>ch5</code> 接收并建立来自远端副本 <code>ch6</code> 的连接。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Connected ClickHouse Follower replica version 19.17.0, revision: 54428, database: default, user: default</span><br></pre></td></tr></table></figure>
</li>
<li><p>由主副本制定 <code>MERGE</code> 计划并推送 <code>Log</code> 日志<br>由主副本 <code>ch5   </code> 制定 <code>MERGE</code> 计划，并判断哪些分区需要被合并。在选定之后 <code>ch5</code> 将合并计划转换为 <code>Log</code> 日志对象并推送 <code>Log</code> 日志，以通知所有副本开始合并。日志的核心信息如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">type: merge</span><br><span class="line">202205_0_0_0</span><br><span class="line">202205_1_1_0</span><br><span class="line">into</span><br><span class="line">202205_0_1_1</span><br></pre></td></tr></table></figure>
<p>从日志内容可以看出操作类型为 <code>MERGE</code> 合并，而这次需要合并的分区目录是 <code>202205_0_0_0</code> 和 <code>202205_0_1_1</code>。与此同时主副本还会锁住执行线程，对日志的接收情况进行监听：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Waiting for queue-0000000002 to disapper from ch5.vgbhfive.cn queue</span><br></pre></td></tr></table></figure>
<p>其监听行为由 <code>replication_alter_partitions_sync</code> 参数控制，默认值为 <code>1</code>。</p>
<ul>
<li>参数为 <code>0</code> 时，不做任何等待。</li>
<li>参数为 <code>1</code> 时，只等主副本自身完成。</li>
<li>参数为 <code>0</code> 时，等待所有副本拉取完成。</li>
</ul>
</li>
<li><p>各个副本分别拉取 <code>Log</code> 日志<br><code>ch5</code> 和 <code>ch6</code> 两个副本实例将分别监听 <code>/log/log-00000002</code> 日志的推送，他们分别会拉取日志到本地，并推送到各自的 <code>/queue</code> 任务队列：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Pulling 1 entries to queue : log-00000002 - log-000000002</span><br></pre></td></tr></table></figure>
</li>
<li><p>各个副本分别在本地执行 <code>MERGE</code><br><code>ch5</code> 和 <code>ch6</code> 基于各自的 <code>/queue</code> 队列开始执行任务：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Executing log entry to merge parts 202205_0_0_0, 202205_1_1_0 to 202205_0_1_1</span><br></pre></td></tr></table></figure>
<p>各个副本开始在本地执行 <code>MERGE</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Merged 2 parts: from 202205_0_0_0 to 202205_1_1_0</span><br></pre></td></tr></table></figure></li>
</ol>
<p>至此 <code>MERGE</code> 的合并过程 <code>ZooKeeper</code> 不会进行任何实质性的数据传输，所有的合并操作最终都是由各个副本在本地完成的。而无论合并动作在哪个副本被触发，最终都会交由主副本负责合并计划的制定、消息日志的推送以及日志接收情况的监控。</p>
<h6 id="MUTATION-执行流程"><a href="#MUTATION-执行流程" class="headerlink" title="MUTATION 执行流程"></a><code>MUTATION</code> 执行流程</h6><p>当对 <code>ReplicatedMergeTree</code> 执行 <code>ALTER DELTE</code> 或者 <code>ALTER UPDATE</code> 操作的时候，即会进入 <code>MUTATION</code> 部分的逻辑，与 <code>MERGE</code> 类似，无论 <code>MUTATION</code> 操作从哪个副本发起，首先都会由主副本进行响应。</p>
<ol>
<li>推送 <code>MUTATION</code> 日志<br>在 <code>ch6</code> 节点尝试通过 <code>DELETE</code> 来删除一行数据，执行如下命令：<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> replicated_sales_1 <span class="keyword">DELETE</span> <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure>
上述命令执行之后该副本会接着执行两个重要事项：</li>
</ol>
<ul>
<li>创建 <code>MUTATION ID</code>： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Created mutation with ID 000000000</span><br></pre></td></tr></table></figure></li>
<li>将 <code>MUTATION</code> 操作转换为 <code>MutatutionEntry</code> 日志，并推送到 <code>/mutations/00000000</code>。<code>Mutation</code> 的核心属性如下： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">/mutations/000000000</span><br><span class="line">source replica: ch6.vgbhfive.cn</span><br><span class="line">mutation_id: 2</span><br><span class="line">partition_id: 202205</span><br><span class="line">commands: DELETE where id = \&#x27;1\&#x27;</span><br></pre></td></tr></table></figure></li>
</ul>
<ol start="2">
<li><p>所有副本实例各自监听 <code>MUTATION</code> 日志<br><code>ch5</code> 和 <code>ch6</code> 都会监听 <code>/mutations</code> 节点，因此有新的日志子节点加入都会被实时感知：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Loading 1 mutation entries: 000000000 - 000000000</span><br></pre></td></tr></table></figure>
<p>当监听到有新的 <code>MUTATION</code> 日志加入时，并不是所有副本都会直接做出响应，他们首先会判断自己是否为主副本。</p>
</li>
<li><p>由主副本实例响应 <code>MUTATION</code> 日志并推送 <code>Log</code> 日志<br>只有主副本才会响应 <code>MUTATION</code> 日志，主副本会将 <code>MUTATION</code> 日志转换为 <code>LogEntry</code> 日志并推送到 <code>/log</code> 节点，以通知各个副本执行具体的操作。日志的核心信息如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">/log/log-000000003</span><br><span class="line">source replica: ch5.vgbhfive.cn</span><br><span class="line">block_id:</span><br><span class="line">type: mutate</span><br><span class="line">202005_0_1_1 to 202205_0_1_1_2</span><br></pre></td></tr></table></figure>
</li>
<li><p>各个副本实例分别拉取 <code>Log</code> 日志<br><code>ch5</code> 和 <code>ch6</code> 两个副本分别监听 <code>/log/log-000000002</code> 日志的推送，他们也会分别拉取日志到本地，并推送到各自的 <code>/queue</code> 任务队列：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Pulling 1 entries to queue: log-0000000002 - log-0000000002</span><br></pre></td></tr></table></figure>
</li>
<li><p>各个副本实例分别在本地执行 <code>MUTATION</code><br><code>ch5</code> 和 <code>ch6</code> 基于各自的 <code>/queue</code> 队列开始执行任务：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Executing log entry to mutate part 202205_0_1_1 to 202205_0_1_1_2</span><br></pre></td></tr></table></figure>
<p>各个副本开始在本地执行 <code>MUTATION</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Cloning part 202205_0_1_1 to tmp_clone_202205_0_1_1_2</span><br><span class="line">Renaming temporary part tmp_clone_202205_0_1_1_2 to 202205_0_1_1_2.</span><br></pre></td></tr></table></figure></li>
</ol>
<p>至此在 <code>MUTATION</code> 的整个过程中 <code>ZooKeeper</code> 同样不会进行任何实质性的数据传输。所有的 <code>MUTATION</code> 操作，最终都是由各个副本在本地完成的，而 <code>MUTATION</code> 操作是经过 <code>/mutations</code> 节点实现分发的。本着谁执行谁负责的原则，执行命令的副本负责消息推送，但是无论在哪个副本执行最终都会被交由主副本，再由主副本负责推送 <code>Log</code> 日志，以通知各个副本最终的 <code>MUTATION</code> 逻辑，同时也由主副本对日志接收的情况进行监控。</p>
<h6 id="ALTER-执行流程"><a href="#ALTER-执行流程" class="headerlink" title="ALTER 执行流程"></a><code>ALTER</code> 执行流程</h6><p>当对 <code>ReplicatedMergeTree</code> 执行 <code>ALTER</code> 操作的时候，即会进入 <code>ALTER</code> 部分的逻辑，与前几个类似 <code>ALTER</code> 流程会简单许多，其执行流程并不会涉及 <code>/log</code> 日志的分发。</p>
<ol>
<li><p>修改共享元数据<br>在 <code>ch6</code> 节点尝试增加一个列字段，执行语句如下：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> replicated_sales_1 <span class="keyword">ADD</span> <span class="keyword">COLUMN</span> id2 String</span><br></pre></td></tr></table></figure>
<p>执行之后，<code>ch6</code> 会修改 <code>ZooKeeper</code> 内的共享元数据节点：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/metadata, /columns</span><br><span class="line">Updated shared metadata nodes in ZooKeeper. Waiting for replicas to apply changes.</span><br></pre></td></tr></table></figure>
<p>数据修改之后，节点的版本号也会同时提升：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Version of metadata nodes in ZooKeeper changed. Waiting for structure write lock.</span><br></pre></td></tr></table></figure>
<p>与此同时，<code>ch6</code> 还会负责监听所有副本的修改完成情况：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Waiting for ch5.vgbhfive.cn to apply changes.</span><br><span class="line">Waiting for ch6.vgbhfive.cn to apply changes.</span><br></pre></td></tr></table></figure>
</li>
<li><p>监听共享元数据变更并各自执行本地修改<br><code>ch5</code> 和 <code>ch6</code> 两个副本分别监听共享元数据的变更，之后会分别对本地的元数据版本号与共享版本号进行对比。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Metadata changed in ZooKeeper. Applying changes locally.</span><br><span class="line">Applied changes to the metadata of the table.</span><br></pre></td></tr></table></figure>
</li>
<li><p>确认所有副本完成修改<br>确认所有副本均已完成修改：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ALTER finished.</span><br><span class="line">Done processing query.</span><br></pre></td></tr></table></figure></li>
</ol>
<p>至此整个 <code>ALTER</code> 流程结束。在执行过程中，<code>ZooKeeper</code> 没有参与实质性的数据传输，所有的 <code>ALTER</code> 都是各个副本在本地完成的。</p>
<hr>

<h3 id="分片"><a href="#分片" class="headerlink" title="分片"></a>分片</h3><p>通过引入数据副本可以降低数据丢失的风险，并提升查询的性能，但是仍然有一个问题没有解决，那就是数据表的容量问题，到目前为止每个副本都是保存全量的数据。</p>
<p><code>ClickHouse</code> 中的每个节点都可以称为一个 <code>shard</code> （分片），对于一个完整的方案来说，还需要考虑数据在写入时数据如何被均匀地被写入到各个分片中，以及在数据查询时如何路由到每个分片并组合成结果集，所以 <code>ClickHouse</code> 地数据分片需要结合 <code>Distributed</code> 表引擎一同使用。</p>
<p><code>Distributed</code> 表引擎自身不存储任何数据，它能够作为分布式表的一层透明代理，在集群内部自动开展数据的写入、分发、查询、路由等工作。</p>
<h4 id="集群的配置方式"><a href="#集群的配置方式" class="headerlink" title="集群的配置方式"></a>集群的配置方式</h4><p>在 <code>ClickHouse</code> 中集群配置用 <code>shard</code> 代表分片，用 <code>replica</code> 代表副本。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># 1 分片 0 副本</span><br><span class="line"><span class="tag">&lt;<span class="name">shard</span>&gt;</span><span class="comment">&lt;!-- 分片 --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">replica</span>&gt;</span><span class="comment">&lt;!-- 副本 --&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">replica</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">shard</span>&gt;</span></span><br><span class="line"># 1 分片 1 副本</span><br><span class="line"><span class="tag">&lt;<span class="name">shard</span>&gt;</span><span class="comment">&lt;!-- 分片 --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">replica</span>&gt;</span><span class="comment">&lt;!-- 副本 --&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">replica</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">replica</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">replica</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">shard</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>这样的配置貌似有点问题，其实分片更像是逻辑层面的分组，而无论是分片或时副本，承载他们的都是 <code>replica</code>，所以从某种角度来看，副本也是分片。</p>
<h4 id="集群分布式-DDL"><a href="#集群分布式-DDL" class="headerlink" title="集群分布式 DDL"></a>集群分布式 <code>DDL</code></h4><p>在默认情况下 <code>CREATE</code> 、 <code>DROP</code> 、 <code>RENAME</code> 、 <code>ALTER</code> 等 <code>DDL</code> 语句并不支持分布式执行，但是在加入集群配置后使用新的语法实现分布式 <code>DDL</code> 执行：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span><span class="operator">/</span><span class="keyword">DROP</span><span class="operator">/</span>RENAME<span class="operator">/</span><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> OM CLUSTER cluster_name</span><br></pre></td></tr></table></figure>
<p><small><code>cluster_name</code> 对应了配置文件中的集群名称，<code>ClickHouse</code> 会根据集群配置信息分别去各个节点执行 <code>DDL</code> 语句。</small></p>
<h5 id="数据结构-1"><a href="#数据结构-1" class="headerlink" title="数据结构"></a>数据结构</h5><p>与 <code>ReplicatedMergeTree</code> 类似，分布式 <code>DDL</code> 语句在执行的过程中也需要借助 <code>ZooKeeper</code> 的协同能力，以实现日志分发。</p>
<ol>
<li><p><code>ZooKeeper</code> 内的节点结构<br>默认情况下分布式 <code>DDL</code> 在 <code>ZooKeeper</code> 内使用的根路径为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/clickhouse/task_queue/ddl</span><br></pre></td></tr></table></figure>
<p><small>该地址可以在 <code>config.xml</code> 中的 <code>distributed_ddl</code> 配置指定。</small><br>当然在此节点之下还有其他的监听节点，包含 <code>/query-[seq]</code>，其内包含 <code>DDL</code> 操作日志，每执行一次分布式 <code>DDL</code> 查询，在该节点下新增一条操作日志。<code>DDL</code> 操作日志使用 <code>ZooKeeper</code> 的持久顺序型节点，每条指令的名称以 <code>query-</code> 为前缀，后面的序号递增。在该操作日志下，还有两条状态节点：</p>
<ul>
<li><code>/query-[seq]/active</code> 用于状态监控等用途，在任务的执行过程中，在该节点下会临时保存当前集群内状态为 <code>active</code> 的节点。</li>
<li><code>/query-[seq]/finished</code> 用于检查任务完成情况，在任务的执行过程中，每当集群内的某个 <code>host</code> 执行完毕之后，就会在该节点下写入记录。</li>
</ul>
</li>
<li><p><code>DDLLongEntry</code> 日志对象的数据结构<br>在 <code>/query-[seq]</code> 下记录的日志信息由 <code>DDLLogEntry</code> 承载，拥有以下几个核心属性：</p>
<ul>
<li><code>query</code> 记录 <code>DDL</code> 查询的执行语句  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">query: DROP TABLE default.test_1_local ON CLUSTER shard_2</span><br></pre></td></tr></table></figure></li>
<li><code>hosts</code> 记录指定集群的主机列表，集群由分布式 <code>DDL</code> 语句中的 <code>ON CLUSTER</code> 指定  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hosts: [&#x27;ch5.vgbhfive.cn:9000&#x27;, &#x27;ch6.vgbhfive.cn:9000&#x27;]</span><br></pre></td></tr></table></figure></li>
<li><code>initiator</code> 记录初始化 <code>host</code> 主机的名称，主机列表来源于初始化 <code>host</code> 节点上的集群  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">initiator: ch5.vgbhfive.cn</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>分布式 <code>DDL</code> 的核心执行流程<br><img src="https://s2.loli.net/2022/09/10/xETJYlW2Ic4dft3.png" alt="click-4-1.png"><br>整个流程从上到下按照时间顺序进行，其大致分为三个步骤：</p>
<ul>
<li>推送 <code>DDL</code> 日志，在节点执行语句，本着谁执行谁负责原则，会由这个节点创建 <code>DDLLogEntry</code> 日志并将日志推送到 <code>ZooKeeper</code> ，同时也会由这个节点负责监控任务的执行进度。</li>
<li>拉取日志并执行，其余节点监听到日志推送，于是拉取日志到本地。首先判断自身 <code>host</code> 是否被包含在 <code>DDLLogEntry</code> 的 <code>hosts</code> 列表中，如果包含在内则进入执行流程，执行完毕后将状态写入 <code>finished</code> 节点；如果不包含则忽略这次日子的推送。</li>
<li>确认执行进度，在执行 <code>DDL</code> 语句之后，客户端会阻塞等待 <code>180</code> 秒后，以期望所有 <code>host</code> 执行完毕。如果等待时间超过 <code>180</code> 秒，则进入后台线程继续等待（等待时间由 <code>distributed_ddl_task_timeout</code> 参数执行，默认 <code>180</code> 秒）。</li>
</ul>
</li>
</ol>
<h4 id="Distributed-原理解析"><a href="#Distributed-原理解析" class="headerlink" title="Distributed 原理解析"></a><code>Distributed</code> 原理解析</h4><p><code>Distributed</code> 表引擎是分布式表的代名词，它自身不存储任何数据，而是作为数据分片的透明代理，能够自动路由数据至集群中的各个节点，所以 <code>Distributed</code> 表引擎需要和其他数据表引擎一起协同工作。<br>从实体表层面来看，一张分片由两部分组成：</p>
<ul>
<li>本地表：通常以 <code>_local</code> 为后缀进行命名。本地表是承接数据的载体，可以使用非 <code>Distributed</code> 的任意表引擎，一张本地表对应了一个数据分片。</li>
<li>分布式表：通常以 <code>_all</code> 为后缀进行命名。分布式表是能使用 <code>Distributed</code> 表引擎，他与本地表形成一对多的映射关系，日后将通过分布式表代理操作多张本地表。</li>
</ul>
<p><small><code>Distirbuted</code> 表引擎采用读时检查，即在查询时才会抛出错误，而不会在创建表时检查。</small> </p>
<h5 id="定义形式"><a href="#定义形式" class="headerlink" title="定义形式"></a>定义形式</h5><p><code>Distributed</code> 表引擎的定义形式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ENGINE = Distributed(cluster, database, table [, sharding_key])</span><br></pre></td></tr></table></figure>
<p>其中各个参数的含义如下：</p>
<ul>
<li><code>cluster</code>：集群名称，与集群配置中的自定义名称相对应。在对分布式表执行写入和查询的过程中，他会使用集群的配置信息来找到相应的 <code>host</code> 节点。</li>
<li><code>dataabse</code> 和 <code>table</code>：分别对应数据库和表的名称，分布式表使用这组配置映射到本地表。</li>
<li><code>sharding_key</code>：分片键，选填参数。在数据写入的过程中，分布式表会依据分片键的规则，将数据分布到各个 <code>host</code> 节点的本地表。</li>
</ul>
<h5 id="查询分类"><a href="#查询分类" class="headerlink" title="查询分类"></a>查询分类</h5><p><code>Distributed</code> 表引擎的查询操作分类如下：</p>
<ul>
<li>会作用于本地表的查询，对于 <code>INSERT</code> 和 <code>SELECT</code> 查询，<code>Distributed</code> 将会以分布式的方式作用于 <code>local</code> 本地表。</li>
<li>只会影响 <code>Distributed</code> 自身，不会作用于本地表的查询： <code>Distributed</code> 支持部分元数据操作，包括 <code>CREATE</code> 、 <code>DROP</code> 、 <code>REANME</code> 、 <code>ALTER</code>，其中 <code>ALTER</code> 并不包括分区的操作。</li>
<li>不支持的查询：<code>Distributed</code> 表不支持任何 <code>MUTATION</code> 类型的操作，包括 <code>ALTER DELETE</code> 和 <code>ALTER UPDATE</code>。</li>
</ul>
<h5 id="分片规则"><a href="#分片规则" class="headerlink" title="分片规则"></a>分片规则</h5><p>分片键要求返回一个整数类型的取值，包括 <code>Int</code> 类型和 <code>UInt</code> 类型。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Distributed(cluster, database, table, userid) # 按照用户 id 的余数划分</span><br></pre></td></tr></table></figure>

<p><small>如果不声明分片键，那么分布式表则只会有一个分片，意味者只能映射一张本地表。当然如果分布式表只包含一个分片，那也就失去了使用的意义。</small></p>
<p>关于数据如何被具体的划分，需要明确以下几个概念：</p>
<ul>
<li>分片权重<br>  在集群的配置中，还有一项分片权重（<code>weight</code>）的设置：  <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">shard</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">weight</span>&gt;</span>10<span class="tag">&lt;/<span class="name">weight</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">shard</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">shard</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">weight</span>&gt;</span>20<span class="tag">&lt;/<span class="name">weight</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">shard</span>&gt;</span></span><br></pre></td></tr></table></figure>
  分片权重会影响数据在分片中的倾斜程度，一个分片权重值越大，那么被写入的数据就会越多。</li>
<li><code>slot</code>（槽）<br>  <code>slot</code> 可以理解成许多个小水槽，如果把数据比作成水的话，那么数据之水会顺着这些水槽流进每个数据分片。<code>slot</code> 的数量等于所有分片的权重之和。</li>
<li>选择函数<br>  选择函数用于判断一行待写入的数据应该被写入到哪个分片，那整个步骤会被分为两个步骤：<ul>
<li>找出 <code>slot</code> 的取值，计算公式如下：   <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">slot = shard_value - sum_weight</span><br></pre></td></tr></table></figure>
   其中 <code>shard_value</code> 是分片键的取值，<code>sum_weight</code> 是所有分片的权重之和。</li>
<li>基于 <code>slot</code> 值找到对应的数据分片</li>
</ul>
</li>
</ul>
<h5 id="分布式核心流程"><a href="#分布式核心流程" class="headerlink" title="分布式核心流程"></a>分布式核心流程</h5><h6 id="分布式写入流程"><a href="#分布式写入流程" class="headerlink" title="分布式写入流程"></a>分布式写入流程</h6><p>在向集群内的分片写入数据时，通常有两种思路：一种是借助外部计算系统，事先将数据均匀分片，再借由计算系统直接写入 <code>ClickHouse</code>集群的各个本地表。第二种则是通过 <code>Distributed</code> 表引擎代理写入分片数据的。</p>
<h6 id="将数据写入分片的核心流程"><a href="#将数据写入分片的核心流程" class="headerlink" title="将数据写入分片的核心流程"></a>将数据写入分片的核心流程</h6><p>在对 <code>Distributed</code> 表执行 <code>INSERT</code> 查询的时候，会进入数据写入分片的执行逻辑，可以分为五个步骤，整体流程如下：</p>
<ol>
<li><p>在第一个分片节点写入本地分片数据<br>在 <code>ch5</code> 节点对本地表 <code>test_shard_2_all</code> 执行 <code>INSERT</code> 查询，尝试写入 <code>10, 30, 200, 50</code> 四行数据。执行之后分布式表主要分做两件事情：其一，根据分片规则划分数据；第二，将属于当前分片的数据直接写入本地表 <code>test_shard_2_all</code>。</p>
</li>
<li><p>第一个分片建立远端连接，准备发送远端分片数据<br>将归至远端分片的数据以分区为单位，分别写入 <code>test_shard_2_all</code> 存储目录下的临时 <code>bin</code> 文件，数据文件的命名规则如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/database@host:port/[increase_num].bin</span><br></pre></td></tr></table></figure>
<p>由于在这个示例中只有一个远端分片 <code>ch6</code>，所以临时数据文件如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/test_shard_2_all/default@ch6.vgbhfive.cn:9000/1.bin</span><br></pre></td></tr></table></figure>
<p><code>10, 200, 50</code> 三行数据会被写入上述临时数据文件。接着会尝试与远端 <code>ch6</code> 分片建立连接：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Connection (ch6.vgbhfive.cn) : Connected to ClickHouse server</span><br></pre></td></tr></table></figure>
</li>
<li><p>第一个分片向远端分片发送数据<br>此时会有另一组监听任务负责监听 <code>/test_shard_2_all</code> 目录下的文件变化，这些任务负责将目录数据发送至远端分片：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">test_shard_2_all.Distributed.DirectoryMonitor:</span><br><span class="line">Started processing /test_shard_2_all/default@ch6.vgbhfive.cn:9000/1.bin</span><br></pre></td></tr></table></figure>
<p>其中，每份目录将会由独立的线程负责发送，数据在传输之前会被压缩。</p>
</li>
<li><p>第二个分片接收数据并写入本地<br><code>ch6</code> 分片节点确认建立与 <code>ch5</code> 的连接：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">TCPHandlerFactory: TCP Request. Address: ch5:459127</span><br><span class="line">TCPHandler: Connected ClickHouse server</span><br></pre></td></tr></table></figure>
<p>在接收到 <code>ch5</code> 发送的数据后，将他们写入本地表：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">executeQuery: (from ch5) INSERT INTO default.test_shard_2_local</span><br><span class="line">-- 第一个分区</span><br><span class="line">Reserving 1.00 MB on disk &#x27;default&#x27;</span><br><span class="line">Renaming temporary part tmp_insert_10_1_1_0 to 10_1_1_0.</span><br><span class="line">-- 第二个分区</span><br><span class="line">Reserving 1.00 MB on disk &#x27;default&#x27;</span><br><span class="line">Renaming temporary part tmp_insert_200_1_1_0 to 200_1_1_0.</span><br><span class="line">-- 第三个分区</span><br><span class="line">Reserving 1.00 MB on disk &#x27;default&#x27;</span><br><span class="line">Renaming temporary part tmp_insert_50_1_1_0 to 50_1_1_0.</span><br></pre></td></tr></table></figure>
</li>
<li><p>由第一个分片确认完成写入<br>最后由 <code>ch5</code> 分片确认所有的数据发送完毕：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Finished processing /test_shard_2_all/default@ch6.vgbhfive.cn:9000/1.bin</span><br></pre></td></tr></table></figure></li>
</ol>
<p>至此整个流程结束，<code>Distributed</code> 表负责所有分片的写入工作。在由 <code>Distirbuted</code> 表负责向远端分片发送数据时，有异步和同步两种写模式：如果是异步写入则在 <code>Distributed</code> 表写完本地分片之后，<code>INSERT</code> 查询就会返回成功写入的消息；如果是同步写入则在 <code>INSERT</code> 查询之后，会等待所有分片完成写入。使用何种模式由 <code>insert_distributed_sync</code> 参数控制，默认为 <code>false</code>，即异步写入；如果将其设置为 <code>true</code>，则可以进一步通过 <code>insert_distributed_timeout</code> 参数控制同步等待的超时时间。</p>
<h6 id="副本复制数据流程"><a href="#副本复制数据流程" class="headerlink" title="副本复制数据流程"></a>副本复制数据流程</h6><p>除了刚才的分片写入流程之外，还会触发副本数据的复制流程。数据在多个副本之间，有两种复制实现方式：一种是继续借助 <code>Distributed</code> 表引擎，由它将数据写入副本。另一种则是借助 <code>ReplicatedMergeTree</code> 表引擎实现副本数据的分发。</p>
<h6 id="分布式查询流程"><a href="#分布式查询流程" class="headerlink" title="分布式查询流程"></a>分布式查询流程</h6><p>与数据写入有所不同，在面向集群查询数据的时候，只能通过 <code>Distributed</code> 表引擎实现。当 <code>Distributed</code> 表接收到 <code>SELECT</code> 查询的时候，他会依次查询每个分片的数据，再合并汇总返回。</p>
<ol>
<li><p>多副本的路由规则<br>在查询数据的时候，如果集群中的一个 <code>shard</code>，拥有多个 <code>replica</code>，那么 <code>Distributed</code> 表引擎需要面临副本选择的问题。他会使用负载均衡算法从众多 <code>replica</code> 中选择一个，而具体使用何种负载均衡算法，则由 <code>load_balancing</code> 参数控制：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">load_balancing = random / nearest_hostname / in_order / first_or_random</span><br></pre></td></tr></table></figure>
<p>有四种负载均衡算法：</p>
<ul>
<li><code>random</code></li>
<li><code>nearest_hostname</code></li>
<li><code>in_order</code></li>
<li><code>first_or_random</code></li>
</ul>
</li>
<li><p>多分片查询<br>分布式查询与分布式写入类似，同样本着谁执行谁负责的原则，他会接收 <code>SELECT</code> 查询的 <code>Distributed</code> 表并负责串联起整个过程。首先他会针对分布式表的 <code>SQL</code> 语句，按照分片数量将查询拆分为若干个本地表的子查询，然后向各个分片发起查询，然后再汇总各个分片的返回结果。</p>
</li>
</ol>
<hr>

<h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><hr>

<h3 id="个人备注"><a href="#个人备注" class="headerlink" title="个人备注"></a>个人备注</h3><p><strong>此博客内容均为作者学习所做笔记，侵删！</strong><br><strong>若转作其他用途，请注明来源！</strong></p>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/ClickHouse/" rel="tag"># ClickHouse</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/ClickHouse-MergeTree%E5%8E%9F%E7%90%86/" rel="prev" title="ClickHouse-MergeTree原理">
      <i class="fa fa-chevron-left"></i> ClickHouse-MergeTree原理
    </a></div>
      <div class="post-nav-item">
    <a href="/ClickHouse-%E7%AE%A1%E7%90%86%E4%B8%8E%E8%BF%90%E7%BB%B4/" rel="next" title="ClickHouse-管理与运维">
      ClickHouse-管理与运维 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          
    <div class="comments" id="gitalk-container"></div>

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A6%82%E8%BF%B0"><span class="nav-number">1.</span> <span class="nav-text">概述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%89%AF%E6%9C%AC"><span class="nav-number">2.</span> <span class="nav-text">副本</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#ZooKeeper-%E9%85%8D%E7%BD%AE%E6%96%B9%E5%BC%8F"><span class="nav-number">2.1.</span> <span class="nav-text">ZooKeeper 配置方式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%89%AF%E6%9C%AC%E5%AE%9A%E4%B9%89%E5%BD%A2%E5%BC%8F"><span class="nav-number">2.2.</span> <span class="nav-text">副本定义形式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#ReplicatedMergeTree-%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90"><span class="nav-number">2.3.</span> <span class="nav-text">ReplicatedMergeTree 原理解析</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#ZooKeeper-%E8%8A%82%E7%82%B9%E7%BB%93%E6%9E%84"><span class="nav-number">2.3.1.</span> <span class="nav-text">ZooKeeper 节点结构</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="nav-number">2.3.2.</span> <span class="nav-text">数据结构</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%89%AF%E6%9C%AC%E5%8D%8F%E5%90%8C%E6%B5%81%E7%A8%8B"><span class="nav-number">2.3.3.</span> <span class="nav-text">副本协同流程</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%86%99%E5%85%A5%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B"><span class="nav-number">2.3.3.1.</span> <span class="nav-text">写入执行流程</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#MERGE-%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B"><span class="nav-number">2.3.3.2.</span> <span class="nav-text">MERGE 执行流程</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#MUTATION-%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B"><span class="nav-number">2.3.3.3.</span> <span class="nav-text">MUTATION 执行流程</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#ALTER-%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B"><span class="nav-number">2.3.3.4.</span> <span class="nav-text">ALTER 执行流程</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%86%E7%89%87"><span class="nav-number">3.</span> <span class="nav-text">分片</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%9B%86%E7%BE%A4%E7%9A%84%E9%85%8D%E7%BD%AE%E6%96%B9%E5%BC%8F"><span class="nav-number">3.1.</span> <span class="nav-text">集群的配置方式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%9B%86%E7%BE%A4%E5%88%86%E5%B8%83%E5%BC%8F-DDL"><span class="nav-number">3.2.</span> <span class="nav-text">集群分布式 DDL</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-1"><span class="nav-number">3.2.1.</span> <span class="nav-text">数据结构</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Distributed-%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90"><span class="nav-number">3.3.</span> <span class="nav-text">Distributed 原理解析</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%AE%9A%E4%B9%89%E5%BD%A2%E5%BC%8F"><span class="nav-number">3.3.1.</span> <span class="nav-text">定义形式</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%9F%A5%E8%AF%A2%E5%88%86%E7%B1%BB"><span class="nav-number">3.3.2.</span> <span class="nav-text">查询分类</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%88%86%E7%89%87%E8%A7%84%E5%88%99"><span class="nav-number">3.3.3.</span> <span class="nav-text">分片规则</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%88%86%E5%B8%83%E5%BC%8F%E6%A0%B8%E5%BF%83%E6%B5%81%E7%A8%8B"><span class="nav-number">3.3.4.</span> <span class="nav-text">分布式核心流程</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%88%86%E5%B8%83%E5%BC%8F%E5%86%99%E5%85%A5%E6%B5%81%E7%A8%8B"><span class="nav-number">3.3.4.1.</span> <span class="nav-text">分布式写入流程</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%B0%86%E6%95%B0%E6%8D%AE%E5%86%99%E5%85%A5%E5%88%86%E7%89%87%E7%9A%84%E6%A0%B8%E5%BF%83%E6%B5%81%E7%A8%8B"><span class="nav-number">3.3.4.2.</span> <span class="nav-text">将数据写入分片的核心流程</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%89%AF%E6%9C%AC%E5%A4%8D%E5%88%B6%E6%95%B0%E6%8D%AE%E6%B5%81%E7%A8%8B"><span class="nav-number">3.3.4.3.</span> <span class="nav-text">副本复制数据流程</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%88%86%E5%B8%83%E5%BC%8F%E6%9F%A5%E8%AF%A2%E6%B5%81%E7%A8%8B"><span class="nav-number">3.3.4.4.</span> <span class="nav-text">分布式查询流程</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BC%95%E7%94%A8"><span class="nav-number">4.</span> <span class="nav-text">引用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%AA%E4%BA%BA%E5%A4%87%E6%B3%A8"><span class="nav-number">5.</span> <span class="nav-text">个人备注</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="vgbhfive"
      src="https://i.loli.net/2019/12/10/JF3dKDSkZoPz7h6.jpg">
  <p class="site-author-name" itemprop="name">vgbhfive</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">142</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">48</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/vgbhfive" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;vgbhfive" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:vgbhfive@foxmail.com" title="E-Mail → mailto:vgbhfive@foxmail.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://vgbhfive.com/" title="Web-Site → https:&#x2F;&#x2F;vgbhfive.com" rel="noopener" target="_blank"><i class="fab fa-chrome fa-fw"></i>Web-Site</a>
      </span>
  </div>



      </div>
        <div class="back-to-top motion-element">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        
  <div class="beian"><a href="https://beian.miit.gov.cn/" rel="noopener" target="_blank">陕ICP备20002937号-1 </a>
  </div>

<div class="copyright">
  
  &copy; 2016 – 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">vgbhfive</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a>
  </div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="Total Visitors">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="Total Views">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

  

<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.css">

<script>
NexT.utils.loadComments(document.querySelector('#gitalk-container'), () => {
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js', () => {
    var gitalk = new Gitalk({
      clientID    : '2ff0dea213e4c7c0bbcc',
      clientSecret: '7f3d808240b513b00a1dbf20d725809acc316b67',
      repo        : 'vgbhfive.github.io',
      owner       : 'vgbhfive',
      admin       : ['vgbhfive'],
      id          : '3fb6d652ffeb98c20ec9092f83a599e7',
        language: 'zh-CN',
      distractionFreeMode: true
    });
    gitalk.render('gitalk-container');
  }, window.Gitalk);
});
</script>

</body>
</html>
