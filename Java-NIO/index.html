<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="https://i.loli.net/2019/12/10/JF3dKDSkZoPz7h6.jpg">
  <link rel="icon" type="image/png" sizes="16x16" href="https://i.loli.net/2019/12/10/JF3dKDSkZoPz7h6.jpg">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">
  <meta name="google-site-verification" content="G-QBK8PCQC9B">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"blog.vgbhfive.cn","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":true,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":"gitalk","storage":true,"lazyload":false,"nav":null,"activeClass":"gitalk"},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="基础java NIO 主要由以下几个核心部分组成：Channels、Buffers、Selectors，这些构成了核心的API。其他组件，如Pipe、FileLock等，不过是其他三个组件的工具类。 所有的IO在NIO中都是从Channel开始的。Channel有点像流，数据可以从Channel读到Buffer，也可以从Buffer写到Channel。 Channel、BufferChannel的">
<meta property="og:type" content="article">
<meta property="og:title" content="Java-NIO">
<meta property="og:url" content="https://blog.vgbhfive.cn/Java-NIO/index.html">
<meta property="og:site_name" content="Vgbhfive&#39;s Blog">
<meta property="og:description" content="基础java NIO 主要由以下几个核心部分组成：Channels、Buffers、Selectors，这些构成了核心的API。其他组件，如Pipe、FileLock等，不过是其他三个组件的工具类。 所有的IO在NIO中都是从Channel开始的。Channel有点像流，数据可以从Channel读到Buffer，也可以从Buffer写到Channel。 Channel、BufferChannel的">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2019-11-02T03:39:12.000Z">
<meta property="article:modified_time" content="2020-04-29T01:58:08.000Z">
<meta property="article:author" content="vgbhfive">
<meta property="article:tag" content="Java">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://blog.vgbhfive.cn/Java-NIO/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'en'
  };
</script>

  <title>Java-NIO | Vgbhfive's Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<link rel="alternate" href="/atom.xml" title="Vgbhfive's Blog" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Vgbhfive's Blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>About</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-pictures">

    <a href="/pictures/" rel="section"><i class="fa fa-th fa-fw"></i>Pictures</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
        <li class="menu-item menu-item-sitemap">

    <a href="/sitemap.xml" rel="section"><i class="fa fa-sitemap fa-fw"></i>Sitemap</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="reading-progress-bar"></div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://blog.vgbhfive.cn/Java-NIO/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://i.loli.net/2019/12/10/JF3dKDSkZoPz7h6.jpg">
      <meta itemprop="name" content="vgbhfive">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Vgbhfive's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Java-NIO
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2019-11-02 11:39:12" itemprop="dateCreated datePublished" datetime="2019-11-02T11:39:12+08:00">2019-11-02</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-04-29 09:58:08" itemprop="dateModified" datetime="2020-04-29T09:58:08+08:00">2020-04-29</time>
              </span>

          
            <span class="post-meta-item" title="Views" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">Views: </span>
              <span id="busuanzi_value_page_pv"></span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><p>java NIO 主要由以下几个核心部分组成：Channels、Buffers、Selectors，这些构成了核心的API。<br>其他组件，如Pipe、FileLock等，不过是其他三个组件的工具类。</p>
<p>所有的IO在NIO中都是从Channel开始的。Channel有点像流，数据可以从Channel读到Buffer，也可以从Buffer写到Channel。</p>
<h3 id="Channel、Buffer"><a href="#Channel、Buffer" class="headerlink" title="Channel、Buffer"></a>Channel、Buffer</h3><p>Channel的实现：FileChannel、DatagramChannel、SocketChannel、ServerSocketChannel，这些通道涵盖了UDP、TCP网络IO和文件IO，还有一些其他的接口。<br>Buffer的实现：ByteBuffer、CharBuffer、DoubleBuffer、FloatBuffer、IntBuffer、LongBuffer、ShortBuffer，这些Buffer涵盖了你能通过IO所能传送的所有数据类型：short、int、long、byte、char、float、double，还有一个MappedByteBuffer，这个用于表示内存映射文件。</p>
<span id="more"></span>

<h3 id="Selector"><a href="#Selector" class="headerlink" title="Selector"></a>Selector</h3><p>Selector允许单线程处理多个Channel。<br>要使用Selector，必须向Selector注册Channel，然后调用它的select()方法！<br>这个方法会一直阻塞到某个注册的通道有事件就绪，，线程可以处理这些事，如数据连接，数据接收等。</p>
<hr>

<h2 id="Channel的实现"><a href="#Channel的实现" class="headerlink" title="Channel的实现"></a>Channel的实现</h2><p>java NIO的通道类似于流，但又与流不同：</p>
<ul>
<li>通道即可以读取数据，也可以写入数据，但流的读写通常是分开的。</li>
<li>通道可以异步的读写。</li>
<li>通道中的数据总是先读到一个Buffer，或者从一个Buffer中写入。</li>
</ul>
<p>实现：</p>
<ul>
<li>FileChannel：从文件中读写数据。</li>
<li>DatagramChannel：通过UDP读写网络中的数据</li>
<li>SocketChannel：通过TCP读写网络中的数据</li>
<li>ServerSocketChannel：可以监听新进来的TCP连接，像Web服务器那样。</li>
</ul>
<hr>

<h2 id="Buffer的实现"><a href="#Buffer的实现" class="headerlink" title="Buffer的实现"></a>Buffer的实现</h2><p>JAVA NIO中的Buffer用于和NIO通道进行交互，数据从通道读入缓存区，从缓存区写入通道。<br>缓冲区本质上是一块可以写入数据，也可以读出数据的内存，这块内存被包装成NIO Buffer对象，并提供了一组方法，用来方便的调用该块内存。</p>
<ol>
<li>Buffer的基本用法<br>使用Buffer读写数据一般有四种个步骤：</li>
</ol>
<ul>
<li>写入数据到Buffer，Buffer会记录写入了多少数据。</li>
<li>调用flip()方法，将Buffer从写模式转换为读模式。</li>
<li>从Buffer中读取数据</li>
<li>调用clear()方法或compact()方法，clear()方法会清空缓存区所有的数据，compact()方法只会清除已经读取的数据。<br>任何未读的数据都会被放到缓存区的起始处，新写入的数据放到缓存区未读取数据的后面。</li>
</ul>
<ol start="2">
<li><p>buffer的capacity、position和limit<br>缓存区本质上是一块可以读写的内存，被包装成NIO Buffer对象。<br>理解Buffer的工作原理，需要熟悉它的三个属性：capacity、position、limit。<br>position和limit的含义取决于Buffer处于读模式还是写模式，但capacity的含义一直不变。<br>capacity：作为一个内存块，Buffer有一个固定的大小，”capacity”<br>limit：Buffer在不同的模式下，可以写入或读取数据的多少。但一般情况下，limit都会被设置为之前position的值。<br>position：当你写入或读取Buffer时，position表示当前的位置，每一次Buffer转换模式时，position都会被初始化为0，position的最大值为capacity-1。</p>
</li>
<li><p>Buffer的类型<br>ByteBuffer、MappedByteBuffer、CharBuffer、DoubleBuffer、FloatBuffer、IntBuffer、LongBuffer、ShortBuffer<br>这里包含了常见的数据类型，也有map类型的数据。</p>
</li>
<li><p>Buffer的分配<br>要想获得一个Buffef对象，首先要对对象进行分配，每一个Buffer类都有一个allocate()方法，用于分配不同的字节给Buffer。</p>
</li>
<li><p>向Buffer中写入数据,写入数据共有两种方式：</p>
</li>
</ol>
<ul>
<li>从Channel中写到Buffer<br> int byteRead &#x3D; inChannel.read(buf);</li>
<li>通过Buffer的put()方法写入到Buffef中<br> buf.put(124);</li>
</ul>
<ol start="6">
<li><p>flip()方法<br>flip()方法将Buffer从写模式转换为读模式。调用flip()方法会将position设置为0，并将limit设置为之前position的值。<br>换句话说就是position现在用于标记读的位置，limit之前写入了多少个byte、char等，现在就能读取多少个char、byte。</p>
</li>
<li><p>从Buffer中读取数据,读取数据有两种方式：</p>
</li>
</ol>
<ul>
<li>从Buffer中读取数据到Channel<br> int byteWrite &#x3D; inChannel.write(buf);</li>
<li>使用get()方法从Buffer中读取数据<br> byte aByte &#x3D; buf.get();</li>
<li>rewind()方法：<br> rewind()方法将position设置为0，所以可以重读Buffer中的所有数据。</li>
</ul>
<ol start="8">
<li>clear()和compact()方法<br>当读取完Buffer中的数据，需要让Buffer准备好再次被写入，可以调用clear()和compact()方法实现。</li>
</ol>
<ul>
<li>clear()：<br> position被设置为0，limit被设置为capacity的值。Buffer被清空，Buffer中的数据并未清除，只是告诉我们该从哪里写入数据。</li>
<li>compact()：<br> compact()方法会将所有未读的数据拷贝到Buffer起始处，然后将position设到最后一个未读元素的后面，limit依旧被设置为capacity，现在Buffer写入数据就不会覆盖未读的数据了。</li>
</ul>
<ol start="9">
<li><p>mark()和reset()方法<br>调用mark()方法可以标记一个特定的position，之后可以通过reset()方法恢复到这个position。</p>
</li>
<li><p>equals()和compareTo()方法<br>使用equals()和conoareTo()比较两个Buffer对象</p>
</li>
</ol>
<ul>
<li>equals()：当满足下列条件时，两个Buffer相等,相同的类型。Buffer中剩余的byte、char等的个数相等。Buffer中所有的剩余的byte、char等都相同。equals()只比较Buffer的一部分，不是每一个在它的元素都比较，实际上，它只比较Buffer中剩余的元素。</li>
<li>compareTo()：<br>compareTo()只比较Buffer的剩余元素byte、char，如果满足下列条件，认为一个Buffer小于另一个Buffer：<br>第一个不相等的元素小于另外一个Buffer中对应的元素。2.&gt;所有的元素都相等，但是第一个Buffer先耗尽（元素数量小于比第二个Buffer少）。</li>
</ul>
<p><small><strong>注：剩余元素是从position到limit之间的元素。</strong></small></p>
<hr>

<h2 id="Scatter（分散）-Gather（聚集）"><a href="#Scatter（分散）-Gather（聚集）" class="headerlink" title="Scatter（分散）&#x2F;Gather（聚集）"></a>Scatter（分散）&#x2F;Gather（聚集）</h2><p>scatter&#x2F;gather用于描述从Channel中读取或者写入到Channel的操作。<br>Scatter从Channel中读取是指在读操作时将读取的数据写入多个Buffer中。<br>Gather写入Channel是指在写操作时将多个Buffer的数据写入同一个Channel。<br>scatter&#x2F;gather通常使用在需要将数据分开处理的场合，例如传输一个由消息头和消息体组成的消息，会将消息头和消息体分散到不同的Buffer中，这样可以方便处理消息头和消息体。</p>
<ol>
<li><p>Scatter Reads<br>是指数据从一个Channel读取到多个Buffer中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ByteBuffer</span> <span class="variable">header</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">128</span>);</span><br><span class="line"><span class="type">ByteBuffer</span> <span class="variable">body</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">ByteBuffer[] bufferArr = &#123;header, body&#125;;</span><br><span class="line">channel.read(bufferArr);</span><br></pre></td></tr></table></figure>
<p> 首先Buffer被写入数组，然后将数组作为参数传入channel.read()，read()方法按照在数组中的顺序将channel中的数据写入到Buffer中，当一个Buffer写满后，才会向另外一个Buffer中写入。<br>Reads在移动前必须写满Buffer，这意味着不适用于动态消息。</p>
</li>
<li><p>Gather Writes<br>是指将数据从多个Buffer写入到同一个channel。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ByteBuffer</span> <span class="variable">header</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">128</span>);</span><br><span class="line"><span class="type">ByteBuffer</span> <span class="variable">body</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">ByteBuffer[] bufferArr = &#123;header, body&#125;;</span><br><span class="line">channel.write(bufferArr);</span><br></pre></td></tr></table></figure>
<p> bufferArr数组是write()的参数，write()方法会按照在数组中的顺序，将数据写入到channel中，注意只有position和limit之间的数据才会被写入。 因此与Scatter read()相反，Gather write()能较好的处理动态消息。</p>
</li>
</ol>
<h3 id="通道之间的数据传输"><a href="#通道之间的数据传输" class="headerlink" title="通道之间的数据传输"></a>通道之间的数据传输</h3><p>在JAVA NIO中，如果两个通道中有一个是FileChannel，那你可以直接从一个Channel传入到另一个Channel。</p>
<ol>
<li>transferForm()<br>FileChannel的transForm()方法可以将数据从源通道传输到FileChannel中。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">RandomAccessFile</span> <span class="variable">fromFile</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RandomAccessFile</span>(<span class="string">&quot;fromFile.txt&quot;</span>, <span class="string">&quot;rw&quot;</span>);</span><br><span class="line"><span class="type">FileChannel</span> <span class="variable">fromChannel</span> <span class="operator">=</span> fromFile.getChannel();</span><br><span class="line"><span class="type">RandomAccessFile</span> <span class="variable">toFile</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RandomAccessFile</span>(<span class="string">&quot;toFile.txt&quot;</span>, <span class="string">&quot;rw&quot;</span>);</span><br><span class="line"><span class="type">FileChannel</span> <span class="variable">toChannel</span> <span class="operator">=</span> toFile.getChannel();</span><br><span class="line"><span class="type">long</span> <span class="variable">position</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="type">long</span> <span class="variable">count</span> <span class="operator">=</span> fromChannel.size();</span><br><span class="line">toChannel.transferFrom(position, count, fromChannel);</span><br></pre></td></tr></table></figure>
 传入的参数position表示从position处开始向目标文件写入数据，count表示最多传输的字节数。如果源通道的剩余空间小于count字节，则所传输的字节数要小于请求的字节数。<br>另外SocketChannel的实现中，SocketChannel只会传输准备好的数据，因此不会传输所有的数据。</li>
<li>transderTo()<br>FileChannel的transForm()方法可以将数据从源通道传输到FileChannel中。<br>示例：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">RandomAccessFile</span> <span class="variable">fromFile</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RandomAccessFile</span>(<span class="string">&quot;fromFile.txt&quot;</span>, <span class="string">&quot;rw&quot;</span>);</span><br><span class="line"><span class="type">FileChannel</span> <span class="variable">fromChannel</span> <span class="operator">=</span> fromFile.getChannel();</span><br><span class="line"><span class="type">RandomAccessFile</span> <span class="variable">toFile</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RandomAccessFile</span>(<span class="string">&quot;toFile.txt&quot;</span>, <span class="string">&quot;rw&quot;</span>);</span><br><span class="line"><span class="type">FileChannel</span> <span class="variable">toChannel</span> <span class="operator">=</span> toFile.getChannel();</span><br><span class="line"><span class="type">long</span> <span class="variable">position</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="type">long</span> <span class="variable">count</span> <span class="operator">=</span> fromChannel.size();</span><br><span class="line">fronChannel.transferTo(position, count, toChannel);</span><br></pre></td></tr></table></figure>
 除了调用方法的Channel对象不同，其他的都一样。<br>SocketChannel的问题同样存在，SocketChannel会一直传输数据知道目标Buffer被填满。</li>
</ol>
<h2 id="Selector（选择器）"><a href="#Selector（选择器）" class="headerlink" title="Selector（选择器）"></a>Selector（选择器）</h2><p>Selector是Java NIO中能够检测一到多个NIO通道，并能够知道通道是否为读写事件做好准备，这样，一个单独的线程可以管理多个Channel，从而管理多个网络连接。</p>
<ol>
<li><p>为什么使用Selector<br>仅用单个线程就能处理多个Channel。</p>
</li>
<li><p>Selector的创建<br>通过调用Selector.open()方法创建一个Selector。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Selector</span> <span class="variable">selector</span> <span class="operator">=</span> Selector.open();</span><br></pre></td></tr></table></figure>
</li>
<li><p>向Selector注册通道<br>为了将Channel和Selector配合使用，必，须将channel注册到selector上，通过SelectorChannel.register()方法实现。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">channel.configureBlocking(<span class="literal">false</span>);</span><br><span class="line"><span class="type">SelectionKey</span> <span class="variable">key</span> <span class="operator">=</span> channel.register(selector, Selectionkey.OP_READ);</span><br></pre></td></tr></table></figure>
</li>
<li><p>与Selector一起使用，Channel必须处于非阻塞状态。(FileChannel与Selector不能一起使用，因为FileChannel不能切换到非阻塞状态，而套接字通道可以。)</p>
</li>
<li><p>注意register()方法的第二个参数，这是一个”interest集合”，意思是在通过Selector监听Channel时对什么感兴趣，可以监听四种不同类型的事件：Connect、Accept、Read、Write。<br>通道触发了一个事件意思是该事件已就绪，所以，某个channel连接成功到另一个服务器称为“链接就绪”，还有ServerSocketChannel的“接收就绪”，以及其他的“读就绪”，“写就绪”。<br>这四种事件用SlectionKey的四个常量表示：SlectionKey.OP_CONNECT、SelectionKey.OP_ACCEPT、SlectionKey.OP_READ、SelectorKey.OP_WRITE、<br>如果想对多种事件添加监听，可以使用“位或”操作符将常量连接。<br>示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">intereSet</span> <span class="operator">=</span> SelectionKey.OP_READ | SelectionKey.OP_WRITE;</span><br></pre></td></tr></table></figure>
</li>
<li><p>SelectionKey<br>当向Selector注册Channel时，register()方法会返回一个SelectionKey对象，这个对象包含了许多的属性：</p>
</li>
</ol>
<ul>
<li>interest集合<br> interest集合主要包含了你选择的监听事件的集合。可以使用“位与”操作interest集合和给定的SelectionKey常量，确定那些事件在interest集合中。</li>
<li>ready集合<br> ready集合是指已经就绪的操作的集合。</li>
<li>Channel + Selector<br> 从SelectionKey访问Channel和Selector。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> selectionKey.channel();</span><br><span class="line"><span class="type">Selector</span> <span class="variable">selector</span> <span class="operator">=</span> selectionKey.selector();</span><br></pre></td></tr></table></figure></li>
<li>附加的对象<br>可以将一个对象或更多信息附加到SelectionKey上，这样能方便的识别给定的通道。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">selectionKey.attch(theObject);</span><br><span class="line"><span class="type">Object</span> <span class="variable">attachObj</span> <span class="operator">=</span> selectionKey.attachment();</span><br><span class="line"><span class="comment">// 或者</span></span><br><span class="line"><span class="type">SelectionKey</span> <span class="variable">key</span> <span class="operator">=</span> channel.register(selector, SelectionKey.OP_READ, theObject);</span><br></pre></td></tr></table></figure></li>
</ul>
<ol start="7">
<li>通过Selector选择通道<br>一旦向Selector注册通道成功，就可以调用重载的select()方法，这些方法回返回那些已经就绪的通道。</li>
</ol>
<ul>
<li>select()<br>int select()<br>会阻塞到至少一个通道上，等到事件就绪后才返回值。返回值表示有多少通道就绪。<br>int select(long timeout)<br>和select()一样，但除了最长会阻塞timeout时间。<br>int selectNow()<br>不会阻塞，但会不管什么通道都会立即返回。</li>
<li>selectedKeys()<br> 一旦调用select()方法就表示有一个或多个通道就绪，然后通过selector的selectedKey()方法访问“已选择就绪键集”中的就绪通道。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Set</span> <span class="variable">selectedKeys</span> <span class="operator">=</span> selector.selectedKeys();</span><br></pre></td></tr></table></figure>
 当Selector注册Channel时，Channel.register()方法会返回一个SelectionKeys对象，这个对象代表了注册到Selector的通道，可以通过SelectionKey的selectedKeySet()方法访问这些对象。<br>可以遍历这个已选择的键集合来访问就绪的通道。<br>注意在每次使用完SelectionKey实例时，都要在处理完通道时自己移除，下次通道就绪时，Selector会再次将其放入已选择键集中。</li>
</ul>
<ol start="8">
<li><p>wakeUp()<br>某个线程调用select()方法后被阻塞，那要让其从select()返回，需要让其他线程在第一线程调用select()方法的那个对象上调用wakeup()方法即可，阻塞在select()方法上的线程会立刻返回。<br>如果有其他线程调用了wakeup()方法，但当前线程没有阻塞在select()方法上，下个调用select()方法的线程会立即“醒来”（wakeup）。</p>
</li>
<li><p>close()<br>用完Selector后调用close()方法关闭该Selector，且注册到该Selector上的SelectionKey实例无效，但通道本身不会关闭。</p>
</li>
<li><p>完整的示例</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Selector</span> <span class="variable">selector</span> <span class="operator">=</span> Selector.open();</span><br><span class="line">channel.configureBlocking(<span class="literal">false</span>);</span><br><span class="line"><span class="type">SelectionKey</span> <span class="variable">key</span> <span class="operator">=</span> channel.register(selector, SelectionKey.OP_READ);</span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">	<span class="type">int</span> <span class="variable">readyChannel</span> <span class="operator">=</span> selector.select();</span><br><span class="line">	<span class="keyword">if</span> (readyChannel == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">	<span class="type">Set</span> <span class="variable">selectedKeys</span> <span class="operator">=</span> selector.selectedKeys();</span><br><span class="line">	<span class="type">Iterator</span> <span class="variable">keyIterator</span> <span class="operator">=</span> selectedKeys.iterator();</span><br><span class="line">	<span class="keyword">while</span> (keyIterator.hasNext()) &#123;</span><br><span class="line">		<span class="type">SelectionKey</span> <span class="variable">key</span> <span class="operator">=</span> keyIterator.next();</span><br><span class="line">		<span class="keyword">if</span> (key.isAccept())&#123;</span><br><span class="line">		<span class="comment">//a accept</span></span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (key.isConnected()) &#123;</span><br><span class="line">		<span class="comment">//a connected</span></span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (key.isReadable()) &#123;</span><br><span class="line">		<span class="comment">//a read</span></span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (key.isWritable()) &#123;</span><br><span class="line">		<span class="comment">//a write</span></span><br><span class="line">		&#125;</span><br><span class="line">		keyIterator.remove();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<hr>

<h2 id="FileChannel"><a href="#FileChannel" class="headerlink" title="FileChannel"></a>FileChannel</h2><p>Java NIO中的FileChannel是一个连接到文件的通道。可以通过文件通道读写文件。</p>
<p>FileChannel无法设置为非阻塞模式，它总是运行在阻塞模式下。</p>
<ul>
<li><p>打开FileChannel<br>在使用FileChannel之前，必须先打开它。但是，我们无法直接打开一个FileChannel，需要通过使用一个InputStream、OutputStream或RandomAccessFile来获取一个FileChannel实例。下面是通过RandomAccessFile打开FileChannel的示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">RandomAccessFile aFile = new RandomAccessFile(&quot;data/nio-data.txt&quot;, &quot;rw&quot;);</span><br><span class="line">FileChannel inChannel = aFile.getChannel();</span><br></pre></td></tr></table></figure>
</li>
<li><p>从FileChannel读取数据<br>调用多个read()方法之一从FileChannel中读取数据。如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ByteBuffer buf = ByteBuffer.allocate(48);</span><br><span class="line">int bytesRead = inChannel.read(buf);</span><br></pre></td></tr></table></figure></li>
</ul>
<p>首先，分配一个Buffer。从FileChannel中读取的数据将被读到Buffer中。<br>然后，调用FileChannel.read()方法。该方法将数据从FileChannel读取到Buffer中。read()方法返回的int值表示了有多少字节被读到了Buffer中。如果返回-1，表示到了文件末尾。</p>
<ul>
<li><p>向FileChannel写数据<br>使用FileChannel.write()方法向FileChannel写数据，该方法的参数是一个Buffer。如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">String newData = &quot;New String to write to file...&quot; + System.currentTimeMillis();</span><br><span class="line">ByteBuffer buf = ByteBuffer.allocate(48);</span><br><span class="line"></span><br><span class="line">buf.clear();</span><br><span class="line">buf.put(newData.getBytes());</span><br><span class="line"></span><br><span class="line">buf.flip();</span><br><span class="line"></span><br><span class="line">while(buf.hasRemaining()) &#123;</span><br><span class="line">    channel.write(buf);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意FileChannel.write()是在while循环中调用的。因为无法保证write()方法一次能向FileChannel写入多少字节，因此需要重复调用write()方法，直到Buffer中已经没有尚未写入通道的字节。</p>
</li>
<li><p>关闭FileChannel<br>用完FileChannel后必须将其关闭。如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">channel.close();</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><ul>
<li>FileChannel的position方法<br>有时可能需要在FileChannel的某个特定位置进行数据的读&#x2F;写操作。可以通过调用position()方法获取FileChannel的当前位置。</li>
</ul>
<p>也可以通过调用position(long pos)方法设置FileChannel的当前位置。<br>这里有两个例子:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">long pos = channel.position();</span><br><span class="line">channel.position(pos +123);</span><br></pre></td></tr></table></figure>

<p>如果将位置设置在文件结束符之后，然后试图从文件通道中读取数据，读方法将返回-1 —— 文件结束标志。<br>如果将位置设置在文件结束符之后，然后向通道中写数据，文件将撑大到当前位置并写入数据。这可能导致“文件空洞”，磁盘上物理文件中写入的数据间有空隙。</p>
<ul>
<li><p>FileChannel的size方法<br>FileChannel实例的size()方法将返回该实例所关联文件的大小。如:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">long fileSize = channel.size();</span><br></pre></td></tr></table></figure>
</li>
<li><p>FileChannel的truncate方法<br>可以使用FileChannel.truncate()方法截取一个文件。截取文件时，文件将中指定长度后面的部分将被删除。如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">channel.truncate(1024);</span><br></pre></td></tr></table></figure>
<p>这个例子截取文件的前1024个字节。</p>
</li>
<li><p>FileChannel的force方法<br>FileChannel.force()方法将通道里尚未写入磁盘的数据强制写到磁盘上。出于性能方面的考虑，操作系统会将数据缓存在内存中，所以无法保证写入到FileChannel里的数据一定会即时写到磁盘上。要保证这一点，需要调用force()方法。</p>
</li>
</ul>
<p>force()方法有一个boolean类型的参数，指明是否同时将文件元数据（权限信息等）写到磁盘上。<br>下面的例子同时将文件数据和元数据强制写到磁盘上：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">channel.force(true);</span><br></pre></td></tr></table></figure>

<hr>

<h2 id="SocketChannel"><a href="#SocketChannel" class="headerlink" title="SocketChannel"></a>SocketChannel</h2><p>Java NIO中的SocketChannel是一个连接到TCP网络套接字的通道。可以通过以下2种方式创建SocketChannel：</p>
<p>打开一个SocketChannel并连接到互联网上的某台服务器。<br>一个新连接到达ServerSocketChannel时，会创建一个SocketChannel。</p>
<ul>
<li><p>打开 SocketChannel<br>下面是SocketChannel的打开方式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SocketChannel socketChannel = SocketChannel.open();</span><br><span class="line">socketChannel.connect(new InetSocketAddress(&quot;http://jenkov.com&quot;, 80));</span><br></pre></td></tr></table></figure>
</li>
<li><p>关闭 SocketChannel<br>当用完SocketChannel之后调用SocketChannel.close()关闭SocketChannel：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">socketChannel.close();</span><br></pre></td></tr></table></figure>
</li>
<li><p>从 SocketChannel 读取数据<br>要从SocketChannel中读取数据，调用一个read()的方法之一。以下是例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ByteBuffer buf = ByteBuffer.allocate(48);</span><br><span class="line">int bytesRead = socketChannel.read(buf);</span><br></pre></td></tr></table></figure></li>
</ul>
<p>首先，分配一个Buffer。从SocketChannel读取到的数据将会放到这个Buffer中。<br>然后，调用SocketChannel.read()。该方法将数据从SocketChannel 读到Buffer中。read()方法返回的int值表示读了多少字节进Buffer里。如果返回的是-1，表示已经读到了流的末尾（连接关闭了）。</p>
<ul>
<li>写入 SocketChannel<br>写数据到SocketChannel用的是SocketChannel.write()方法，该方法以一个Buffer作为参数。示例如下：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">String newData = &quot;New String to write to file...&quot; + System.currentTimeMillis();</span><br><span class="line">ByteBuffer buf = ByteBuffer.allocate(48);</span><br><span class="line"></span><br><span class="line">buf.clear();</span><br><span class="line"></span><br><span class="line">buf.put(newData.getBytes());</span><br><span class="line"></span><br><span class="line">buf.flip();</span><br><span class="line"></span><br><span class="line">while(buf.hasRemaining()) &#123;</span><br><span class="line">    channel.write(buf);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>注意SocketChannel.write()方法的调用是在一个while循环中的。Write()方法无法保证能写多少字节到SocketChannel。所以，我们重复调用write()直到Buffer没有要写的字节为止。</p>
<ul>
<li><p>非阻塞模式<br>可以设置 SocketChannel 为非阻塞模式（non-blocking mode）.设置之后，就可以在异步模式下调用connect(), read() 和write()了。</p>
</li>
<li><p>connect()<br>如果SocketChannel在非阻塞模式下，此时调用connect()，该方法可能在连接建立之前就返回了。为了确定连接是否建立，可以调用finishConnect()的方法。像这样：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">socketChannel.configureBlocking(false);</span><br><span class="line">socketChannel.connect(new InetSocketAddress(&quot;http://jenkov.com&quot;, 80));</span><br><span class="line"></span><br><span class="line">while(! socketChannel.finishConnect() )&#123;</span><br><span class="line">    //wait, or do something else...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>write()<br>非阻塞模式下，write()方法在尚未写出任何内容时可能就返回了。所以需要在循环中调用write()。前面已经有例子了，这里就不赘述了。</p>
</li>
<li><p>read()<br>非阻塞模式下,read()方法在尚未读取到任何数据时可能就返回了。所以需要关注它的int返回值，它会告诉你读取了多少字节。</p>
</li>
<li><p>非阻塞模式与选择器<br>非阻塞模式与选择器搭配会工作的更好，通过将一或多个SocketChannel注册到Selector，可以询问选择器哪个通道已经准备好了读取，写入等。Selector与SocketChannel的搭配使用会在后面详讲。</p>
</li>
</ul>
<hr>

<h2 id="ServerSocketChannel"><a href="#ServerSocketChannel" class="headerlink" title="ServerSocketChannel"></a>ServerSocketChannel</h2><p>Java NIO中的 ServerSocketChannel 是一个可以监听新进来的TCP连接的通道, 就像标准IO中的ServerSocket一样。ServerSocketChannel类在 java.nio.channels包中。</p>
<p>这里有个例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ServerSocketChannel serverSocketChannel = ServerSocketChannel.open();</span><br><span class="line"> </span><br><span class="line">serverSocketChannel.socket().bind(new InetSocketAddress(9999));</span><br><span class="line"></span><br><span class="line">while(true)&#123;</span><br><span class="line">    SocketChannel socketChannel = serverSocketChannel.accept();</span><br><span class="line"> </span><br><span class="line">    //do something with socketChannel..</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>打开 ServerSocketChannel<br>通过调用 ServerSocketChannel.open() 方法来打开ServerSocketChannel.如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ServerSocketChannel serverSocketChannel = ServerSocketChannel.open();</span><br></pre></td></tr></table></figure>
</li>
<li><p>关闭 ServerSocketChannel<br>通过调用ServerSocketChannel.close() 方法来关闭ServerSocketChannel. 如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">serverSocketChannel.close();</span><br></pre></td></tr></table></figure>
</li>
<li><p>监听新进来的连接<br>通过 ServerSocketChannel.accept() 方法监听新进来的连接。当 accept()方法返回的时候,它返回一个包含新进来的连接的 SocketChannel。因此, accept()方法会一直阻塞到有新连接到达。</p>
</li>
</ul>
<p>通常不会仅仅只监听一个连接,在while循环中调用 accept()方法. 如下面的例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">while(true)&#123;</span><br><span class="line">    SocketChannel socketChannel = serverSocketChannel.accept();</span><br><span class="line">    //do something with socketChannel...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当然,也可以在while循环中使用除了true以外的其它退出准则。</p>
<ul>
<li>非阻塞模式<br>ServerSocketChannel可以设置成非阻塞模式。在非阻塞模式下，accept() 方法会立刻返回，如果还没有新进来的连接,返回的将是null。 因此，需要检查返回的SocketChannel是否是null.如：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">ServerSocketChannel serverSocketChannel = ServerSocketChannel.open();</span><br><span class="line"></span><br><span class="line">serverSocketChannel.socket().bind(new InetSocketAddress(9999));</span><br><span class="line">serverSocketChannel.configureBlocking(false);</span><br><span class="line"></span><br><span class="line">while(true)&#123;</span><br><span class="line">    SocketChannel socketChannel = serverSocketChannel.accept();</span><br><span class="line"></span><br><span class="line">    if(socketChannel != null)</span><br><span class="line">        //do something with socketChannel...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>

<h2 id="DatagranChannel"><a href="#DatagranChannel" class="headerlink" title="DatagranChannel"></a>DatagranChannel</h2><p>Java NIO中的DatagramChannel是一个能收发UDP包的通道。因为UDP是无连接的网络协议，所以不能像其它通道那样读取和写入。它发送和接收的是数据包。</p>
<ul>
<li><p>打开 DatagramChannel<br>下面是 DatagramChannel 的打开方式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">DatagramChannel channel = DatagramChannel.open();</span><br><span class="line">channel.socket().bind(new InetSocketAddress(9999));</span><br></pre></td></tr></table></figure>
<p>这个例子打开的 DatagramChannel可以在UDP端口9999上接收数据包。</p>
</li>
<li><p>接收数据<br>通过receive()方法从DatagramChannel接收数据，如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ByteBuffer buf = ByteBuffer.allocate(48);</span><br><span class="line">buf.clear();</span><br><span class="line">channel.receive(buf);</span><br></pre></td></tr></table></figure></li>
</ul>
<p>receive()方法会将接收到的数据包内容复制到指定的Buffer. 如果Buffer容不下收到的数据，多出的数据将被丢弃。</p>
<ul>
<li>发送数据<br>通过send()方法从DatagramChannel发送数据，如:<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">String newData = &quot;New String to write to file...&quot; + System.currentTimeMillis();</span><br><span class="line">2</span><br><span class="line"> </span><br><span class="line">3</span><br><span class="line">ByteBuffer buf = ByteBuffer.allocate(48);</span><br><span class="line">4</span><br><span class="line">buf.clear();</span><br><span class="line">5</span><br><span class="line">buf.put(newData.getBytes());</span><br><span class="line">6</span><br><span class="line">buf.flip();</span><br></pre></td></tr></table></figure></li>
</ul>
<p>int bytesSent &#x3D; channel.send(buf, new InetSocketAddress(“jenkov.com”, 80));<br>这个例子发送一串字符到”jenkov.com”服务器的UDP端口80。 因为服务端并没有监控这个端口，所以什么也不会发生。也不会通知你发出的数据包是否已收到，因为UDP在数据传送方面没有任何保证。</p>
<ul>
<li>连接到特定的地址<br>可以将DatagramChannel“连接”到网络中的特定地址的。由于UDP是无连接的，连接到特定地址并不会像TCP通道那样创建一个真正的连接。而是锁住DatagramChannel ，让其只能从特定地址收发数据。</li>
</ul>
<p>这里有个例子:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">channel.connect(new InetSocketAddress(&quot;jenkov.com&quot;, 80));</span><br></pre></td></tr></table></figure>

<p>当连接后，也可以使用read()和write()方法，就像在用传统的通道一样。只是在数据传送方面没有任何保证。这里有几个例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">int bytesRead = channel.read(buf);</span><br><span class="line">int bytesWritten = channel.write(but);</span><br><span class="line">````</span><br><span class="line"></span><br><span class="line">&lt;hr&gt;</span><br><span class="line"></span><br><span class="line">## Pipe</span><br><span class="line">Java NIO 管道是2个线程之间的单向数据连接。Pipe有一个source通道和一个sink通道。数据会被写到sink通道，从source通道读取。</span><br><span class="line"></span><br><span class="line">这里是Pipe原理的图示：</span><br><span class="line">![3Ue7D0.png](https://s2.ax1x.com/2020/02/26/3Ue7D0.png)</span><br><span class="line"></span><br><span class="line"> - 创建管道</span><br><span class="line">通过Pipe.open()方法打开管道。例如：</span><br></pre></td></tr></table></figure>
<p>Pipe pipe &#x3D; Pipe.open();</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"> - 向管道写数据</span><br><span class="line">要向管道写数据，需要访问sink通道。像这样：</span><br></pre></td></tr></table></figure>
<p>Pipe.SinkChannel sinkChannel &#x3D; pipe.sink();</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">通过调用SinkChannel的write()方法，将数据写入SinkChannel,像这样：</span><br></pre></td></tr></table></figure>
<p>String newData &#x3D; “New String to write to file…” + System.currentTimeMillis();<br>ByteBuffer buf &#x3D; ByteBuffer.allocate(48);<br>buf.clear();<br>buf.put(newData.getBytes());</p>
<p>buf.flip();</p>
<p>while(buf.hasRemaining()) {<br>    sinkChannel.write(buf);<br>}</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"> - 从管道读取数据</span><br><span class="line">从读取管道的数据，需要访问source通道，像这样：</span><br></pre></td></tr></table></figure>
<p>Pipe.SourceChannel sourceChannel &#x3D; pipe.source();</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">调用source通道的read()方法来读取数据，像这样：</span><br></pre></td></tr></table></figure>
<p>ByteBuffer buf &#x3D; ByteBuffer.allocate(48);</p>
<p>int bytesRead &#x3D; sourceChannel.read(buf);</p>
<pre><code>
read()方法返回的int值会告诉我们多少字节被读进了缓冲区。

&lt;hr&gt;

## JAVA NIO与IO
我应该何时使用IO，何时使用NIO呢？在本文中，我会尽量清晰地解析Java NIO和IO的差异、它们的使用场景，以及它们如何影响您的代码设计。

 - Java NIO和IO的主要区别
下表总结了Java NIO和IO之间的主要差别，我会更详细地描述表中每部分的差异。
IO                NIO
面向流            面向缓冲
阻塞IO            非阻塞IO
无                选择器

 - 面向流与面向缓冲
Java NIO和IO之间第一个最大的区别是，IO是面向流的，NIO是面向缓冲区的。 Java IO面向流意味着每次从流中读一个或多个字节，直至读取所有字节，它们没有被缓存在任何地方。此外，它不能前后移动流中的数据。如果需要前后移动从流中读取的数据，需要先将它缓存到一个缓冲区。 Java NIO的缓冲导向方法略有不同。数据读取到一个它稍后处理的缓冲区，需要时可在缓冲区中前后移动。这就增加了处理过程中的灵活性。但是，还需要检查是否该缓冲区中包含所有您需要处理的数据。而且，需确保当更多的数据读入缓冲区时，不要覆盖缓冲区里尚未处理的数据。

 - 阻塞与非阻塞IO
Java IO的各种流是阻塞的。这意味着，当一个线程调用read() 或 write()时，该线程被阻塞，直到有一些数据被读取，或数据完全写入。该线程在此期间不能再干任何事情了。 Java NIO的非阻塞模式，使一个线程从某通道发送请求读取数据，但是它仅能得到目前可用的数据，如果目前没有数据可用时，就什么都不会获取。而不是保持线程阻塞，所以直至数据变的可以读取之前，该线程可以继续做其他的事情。 非阻塞写也是如此。一个线程请求写入一些数据到某通道，但不需要等待它完全写入，这个线程同时可以去做别的事情。 线程通常将非阻塞IO的空闲时间用于在其它通道上执行IO操作，所以一个单独的线程现在可以管理多个输入和输出通道（channel）。

 - 选择器（Selectors）
Java NIO的选择器允许一个单独的线程来监视多个输入通道，你可以注册多个通道使用一个选择器，然后使用一个单独的线程来“选择”通道：这些通道里已经有可以处理的输入，或者选择已准备写入的通道。这种选择机制，使得一个单独的线程很容易来管理多个通道。

&lt;hr&gt;

## 个人备注
**此博客内容均为作者学习所做笔记，侵删！**
**若转作其他用途，请注明来源！**

</code></pre>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/Java/" rel="tag"># Java</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/JS-%E4%B8%AD%E7%9A%84%E7%A5%9E%E6%93%8D%E4%BD%9C/" rel="prev" title="JS 中的神操作">
      <i class="fa fa-chevron-left"></i> JS 中的神操作
    </a></div>
      <div class="post-nav-item">
    <a href="/Java-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/" rel="next" title="Java-网络编程">
      Java-网络编程 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          
    <div class="comments" id="gitalk-container"></div>

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9F%BA%E7%A1%80"><span class="nav-number">1.</span> <span class="nav-text">基础</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Channel%E3%80%81Buffer"><span class="nav-number">1.1.</span> <span class="nav-text">Channel、Buffer</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Selector"><span class="nav-number">1.2.</span> <span class="nav-text">Selector</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Channel%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="nav-number">2.</span> <span class="nav-text">Channel的实现</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Buffer%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="nav-number">3.</span> <span class="nav-text">Buffer的实现</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Scatter%EF%BC%88%E5%88%86%E6%95%A3%EF%BC%89-Gather%EF%BC%88%E8%81%9A%E9%9B%86%EF%BC%89"><span class="nav-number">4.</span> <span class="nav-text">Scatter（分散）&#x2F;Gather（聚集）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%80%9A%E9%81%93%E4%B9%8B%E9%97%B4%E7%9A%84%E6%95%B0%E6%8D%AE%E4%BC%A0%E8%BE%93"><span class="nav-number">4.1.</span> <span class="nav-text">通道之间的数据传输</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Selector%EF%BC%88%E9%80%89%E6%8B%A9%E5%99%A8%EF%BC%89"><span class="nav-number">5.</span> <span class="nav-text">Selector（选择器）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#FileChannel"><span class="nav-number">6.</span> <span class="nav-text">FileChannel</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%B9%E6%B3%95"><span class="nav-number">6.1.</span> <span class="nav-text">方法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#SocketChannel"><span class="nav-number">7.</span> <span class="nav-text">SocketChannel</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ServerSocketChannel"><span class="nav-number">8.</span> <span class="nav-text">ServerSocketChannel</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#DatagranChannel"><span class="nav-number">9.</span> <span class="nav-text">DatagranChannel</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="vgbhfive"
      src="https://i.loli.net/2019/12/10/JF3dKDSkZoPz7h6.jpg">
  <p class="site-author-name" itemprop="name">vgbhfive</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">140</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">47</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/vgbhfive" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;vgbhfive" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:vgbhfive@foxmail.com" title="E-Mail → mailto:vgbhfive@foxmail.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://vgbhfive.com/" title="Web-Site → https:&#x2F;&#x2F;vgbhfive.com" rel="noopener" target="_blank"><i class="fab fa-chrome fa-fw"></i>Web-Site</a>
      </span>
  </div>



      </div>
        <div class="back-to-top motion-element">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        
  <div class="beian"><a href="https://beian.miit.gov.cn/" rel="noopener" target="_blank">陕ICP备20002937号-1 </a>
  </div>

<div class="copyright">
  
  &copy; 2016 – 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">vgbhfive</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a>
  </div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="Total Visitors">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="Total Views">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

  

<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.css">

<script>
NexT.utils.loadComments(document.querySelector('#gitalk-container'), () => {
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js', () => {
    var gitalk = new Gitalk({
      clientID    : '2ff0dea213e4c7c0bbcc',
      clientSecret: '7f3d808240b513b00a1dbf20d725809acc316b67',
      repo        : 'vgbhfive.github.io',
      owner       : 'vgbhfive',
      admin       : ['vgbhfive'],
      id          : 'ad31089e31215e15722a120ed045dca7',
        language: 'zh-CN',
      distractionFreeMode: true
    });
    gitalk.render('gitalk-container');
  }, window.Gitalk);
});
</script>

</body>
</html>
