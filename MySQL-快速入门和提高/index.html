<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="https://i.loli.net/2019/12/10/JF3dKDSkZoPz7h6.jpg">
  <link rel="icon" type="image/png" sizes="16x16" href="https://i.loli.net/2019/12/10/JF3dKDSkZoPz7h6.jpg">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">
  <meta name="google-site-verification" content="G-QBK8PCQC9B">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"blog.vgbhfive.cn","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":true,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="基础简介MySQL 是最流行的关系型数据库管理系统，在WEB 应用方面MySQL 是最好的RDBMS(Relational Database Management System：关系数据库管理系统)应用软件之一。数据库（Database）是按照数据结构来组织、存储和管理数据的仓库。每个数据库都有一个或多个不同的API 用于创建、访问、管理、搜索和复制所保存的数据。也可以将数据存储在文件中，但是在文">
<meta property="og:type" content="article">
<meta property="og:title" content="MySQL-快速入门和提高">
<meta property="og:url" content="https://blog.vgbhfive.cn/MySQL-%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8%E5%92%8C%E6%8F%90%E9%AB%98/index.html">
<meta property="og:site_name" content="Vgbhfive&#39;s Blog">
<meta property="og:description" content="基础简介MySQL 是最流行的关系型数据库管理系统，在WEB 应用方面MySQL 是最好的RDBMS(Relational Database Management System：关系数据库管理系统)应用软件之一。数据库（Database）是按照数据结构来组织、存储和管理数据的仓库。每个数据库都有一个或多个不同的API 用于创建、访问、管理、搜索和复制所保存的数据。也可以将数据存储在文件中，但是在文">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://i.loli.net/2021/04/24/h2itWYVNZTbvwDm.jpg">
<meta property="og:image" content="https://i.loli.net/2019/07/22/5d3598f989bdb68702.jpg">
<meta property="og:image" content="https://i.loli.net/2019/08/09/EtcuCBm9szT7L4I.jpg">
<meta property="og:image" content="https://i.loli.net/2019/07/22/5d358f50c02b135511.jpg">
<meta property="article:published_time" content="2019-07-07T08:16:05.000Z">
<meta property="article:modified_time" content="2021-04-24T03:06:14.284Z">
<meta property="article:author" content="vgbhfive">
<meta property="article:tag" content="MySQL">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://i.loli.net/2021/04/24/h2itWYVNZTbvwDm.jpg">

<link rel="canonical" href="https://blog.vgbhfive.cn/MySQL-%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8%E5%92%8C%E6%8F%90%E9%AB%98/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'en'
  };
</script>

  <title>MySQL-快速入门和提高 | Vgbhfive's Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<link rel="alternate" href="/atom.xml" title="Vgbhfive's Blog" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Vgbhfive's Blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>About</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-pictures">

    <a href="/pictures/" rel="section"><i class="fa fa-th fa-fw"></i>Pictures</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
        <li class="menu-item menu-item-sitemap">

    <a href="/sitemap.xml" rel="section"><i class="fa fa-sitemap fa-fw"></i>Sitemap</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="reading-progress-bar"></div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://blog.vgbhfive.cn/MySQL-%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8%E5%92%8C%E6%8F%90%E9%AB%98/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://i.loli.net/2019/12/10/JF3dKDSkZoPz7h6.jpg">
      <meta itemprop="name" content="vgbhfive">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Vgbhfive's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          MySQL-快速入门和提高
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2019-07-07 16:16:05" itemprop="dateCreated datePublished" datetime="2019-07-07T16:16:05+08:00">2019-07-07</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-04-24 11:06:14" itemprop="dateModified" datetime="2021-04-24T11:06:14+08:00">2021-04-24</time>
              </span>

          
            <span class="post-meta-item" title="Views" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">Views: </span>
              <span id="busuanzi_value_page_pv"></span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h3 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h3><h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><p><strong>MySQL</strong> 是最流行的关系型数据库管理系统，在WEB 应用方面MySQL 是最好的RDBMS(<strong>Relational Database Management System：关系数据库管理系统</strong>)应用软件之一。<br>数据库（<strong>Database</strong>）是按照数据结构来组织、存储和管理数据的仓库。<br>每个数据库都有一个或多个不同的API 用于创建、访问、管理、搜索和复制所保存的数据。<br>也可以将数据存储在文件中，但是在文件中读写数据速度相对较慢。<br>所以，现在使用关系型数据库管理系统（<strong>RDBMS</strong>）来存储和管理的大数据量。所谓的关系型数据库，是建立在关系模型基础上的数据库，借助于集合代数等数学概念和方法来处理数据库中的数据。<br>RDBMS 即关系数据库管理系统(Relational Database Management System)的特点：</p>
<ul>
<li>数据以表格的形式出现。</li>
<li>每行为各种记录名称。</li>
<li>每列为记录名称所对应的数据域。</li>
<li>许多的行和列组成一张表单。</li>
<li>若干的表单组成database 。</li>
</ul>
<span id="more"></span>

<p><strong>RDBMS</strong> 术语：</p>
<ul>
<li>数据库: 数据库是一些关联表的集合。</li>
<li>数据表: 表是数据的矩阵。在一个数据库中的表看起来像一个简单的电子表格。</li>
<li>表头(header): 每一列的名称。</li>
<li>列: 一列(数据元素) 包含了相同类型的数据, 例如邮政编码的数据。</li>
<li>行：一行（&#x3D;元组或记录）是一组相关的数据，例如一条用户订阅的数据。</li>
<li>值: 行的具体信息, 每个值必须与该列的数据类型相同。</li>
<li>键: 键的值在当前列中具有唯一性。</li>
<li>冗余：存储两倍数据，冗余降低了性能，但提高了数据的安全性。</li>
<li>主键：主键是唯一的。一个数据表中只能包含一个主键。你可以使用主键来查询数据。</li>
<li>外键：外键用于关联两个表。</li>
<li>复合键：复合键（组合键）将多个列作为一个索引键，一般用于复合索引。</li>
<li><strong>索引</strong>：使用索引可快速访问数据库表中的特定信息。索引是对数据库表中一列或多列的值进行排序的一种结构。类似于书籍的目录。</li>
<li><strong>参照完整性</strong>: 参照的完整性要求关系中不允许引用不存在的实体。与实体完整性是关系模型必须满足的完整性约束条件，目的是保证数据的一致性。</li>
</ul>
<h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><h5 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h5><p>示例以Centos7 系统使用yum 命令安装演示。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">wget http:<span class="operator">/</span><span class="operator">/</span>repo.mysql.com<span class="operator">/</span>mysql<span class="operator">-</span>community<span class="operator">-</span><span class="keyword">release</span><span class="operator">-</span>el7<span class="number">-5.</span>noarch.rpm</span><br><span class="line">rpm <span class="operator">-</span>ivh mysql<span class="operator">-</span>community<span class="operator">-</span><span class="keyword">release</span><span class="operator">-</span>el7<span class="number">-5.</span>noarch.rpm</span><br><span class="line">yum <span class="keyword">update</span></span><br><span class="line">yum install mysql<span class="operator">-</span>server</span><br><span class="line">chown mysql:mysql <span class="operator">-</span>R <span class="operator">/</span>var<span class="operator">/</span>lib<span class="operator">/</span>mysql # 权限设置</span><br><span class="line">mysql <span class="comment">--initialize # 初始化MySQL</span></span><br><span class="line">systemctl <span class="keyword">start</span> mysqld # 启动MySQL </span><br><span class="line">systemctl status mysqld # 查看MySQL运行状态</span><br><span class="line">mysqladmin <span class="comment">--version # 验证MySQL安装</span></span><br></pre></td></tr></table></figure>

<h5 id="Windows"><a href="#Windows" class="headerlink" title="Windows"></a>Windows</h5><p>点击链接<a target="_blank" rel="noopener" href="https://www.mysql.com/downloads/">https://www.mysql.com/downloads/</a> 下载你想要的版本。</p>
<h5 id="元数据"><a href="#元数据" class="headerlink" title="元数据"></a>元数据</h5><p>MySQL以下三种信息：</p>
<ul>
<li>查询结果信息： SELECT、UPDATE、DELETE 语句影响的记录数。</li>
<li>数据库和数据表的信息： 包含了数据库及数据表的结构信息。</li>
<li>MySQL服务器信息： 包含了数据库服务器的当前状态、版本号等。</li>
</ul>
<p>命令:</p>
<ul>
<li>SELECT VERSION(): 服务器版本信息</li>
<li>SELECT DATABASE(): 当前数据库名 (或者返回空)</li>
<li>SELECT USER(): 当前用户名</li>
<li>SHOW STATUS: 服务器状态</li>
<li>SHOW VARIABLES: 服务器配置变量</li>
</ul>
<h4 id="基础语法"><a href="#基础语法" class="headerlink" title="基础语法"></a>基础语法</h4><h5 id="操作数据库"><a href="#操作数据库" class="headerlink" title="操作数据库"></a>操作数据库</h5><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mysql <span class="operator">-</span>h 主机名 <span class="operator">-</span>u 用户名 <span class="operator">-</span>p # 登录MySQL</span><br><span class="line"><span class="keyword">create</span> DATABASE vgbh; # 创建数据库</span><br><span class="line"><span class="keyword">drop</span> database vgbh; # 删除数据库</span><br><span class="line">use vgbh; # 使用数据库</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> table_name (column_name column_type); # 创建数据表</span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> table_name; # 删除数据表</span><br></pre></td></tr></table></figure>

<h5 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h5><p>MySQL支持多种类型，大致可以分为三类：</p>
<ul>
<li>数值。(TINYINT、INTEGER、MEDIUMINT、SMALLINT、DECIMAL、NUMERIC、FLOAT、DOUBLE)</li>
<li>日期&#x2F;时间。(DATETIME、DATE、TIMESTAMP、TIME、YEAR)</li>
<li>字符串(字符)类型。(CHAR、VARCHAR、BINARY、VARBINARY、BLOB、TEXT、ENUM、SET)</li>
</ul>
<h5 id="CURD"><a href="#CURD" class="headerlink" title="CURD"></a>CURD</h5><p>Insert:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> table_name (field1, field2,...fieldN) <span class="keyword">VALUES</span> (value1, value2,...valueN);</span><br></pre></td></tr></table></figure>
<p> Select:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> column_name,column_name <span class="keyword">FROM</span> table_name [<span class="keyword">WHERE</span> Clause][LIMIT N][<span class="keyword">OFFSET</span> M]</span><br><span class="line"><span class="keyword">SELECT</span> field1, field2,...fieldN <span class="keyword">FROM</span> table_name <span class="keyword">WHERE</span> field1 <span class="keyword">LIKE</span> condition1 [<span class="keyword">AND</span> [<span class="keyword">OR</span>]] filed2 <span class="operator">=</span> <span class="string">&#x27;somevalue&#x27;</span></span><br></pre></td></tr></table></figure>
<p> Update:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> table_name <span class="keyword">SET</span> field1<span class="operator">=</span><span class="keyword">new</span><span class="operator">-</span>value1, field2<span class="operator">=</span><span class="keyword">new</span><span class="operator">-</span>value2 [<span class="keyword">WHERE</span> Clause]</span><br></pre></td></tr></table></figure>
<p> Delete:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> table_name [<span class="keyword">WHERE</span> Clause]</span><br></pre></td></tr></table></figure>
<p> Alter:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> table_name <span class="keyword">ADD</span> i <span class="type">INT</span>; # 添加字段</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> table_name <span class="keyword">DROP</span> i; # 删除字段</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> table_name MODIFY c <span class="type">CHAR</span>(<span class="number">10</span>); # 修改字段类型</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> table_name CHANGE i j <span class="type">BIGINT</span>; # 修改字段名称</span><br></pre></td></tr></table></figure>

<h5 id="UNION"><a href="#UNION" class="headerlink" title="UNION"></a>UNION</h5><p>MySQL UNION 操作符用于连接两个以上的SELECT 语句的结果组合到一个结果集合中。<br>多个SELECT 语句会删除重复的数据。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> expression1, expression2, ... expression_n <span class="keyword">FROM</span> tables [<span class="keyword">WHERE</span> conditions]</span><br><span class="line"><span class="keyword">UNION</span> [<span class="keyword">ALL</span> <span class="operator">|</span> <span class="keyword">DISTINCT</span>]</span><br><span class="line"><span class="keyword">SELECT</span> expression1, expression2, ... expression_n <span class="keyword">FROM</span> tables [<span class="keyword">WHERE</span> conditions];</span><br></pre></td></tr></table></figure>

<h5 id="分组、排序"><a href="#分组、排序" class="headerlink" title="分组、排序"></a>分组、排序</h5><p>Order by:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> field1, field2,...fieldN <span class="keyword">FROM</span> table_name1, table_name2...</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> field1 [<span class="keyword">ASC</span> [<span class="keyword">DESC</span>][默认 <span class="keyword">ASC</span>]], [field2...] [<span class="keyword">ASC</span> [<span class="keyword">DESC</span>][默认 <span class="keyword">ASC</span>]]</span><br></pre></td></tr></table></figure>
<p> Group by:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> column_name, <span class="keyword">function</span>(column_name) <span class="keyword">FROM</span> table_name <span class="keyword">WHERE</span> column_name </span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> column_name;</span><br></pre></td></tr></table></figure>

<h5 id="连接"><a href="#连接" class="headerlink" title="连接"></a>连接</h5><p>可以在SELECT、UPDATE、DELETE 语句中使用MySQL 的JOIN 来联合多表查询。<br>JOIN 按照功能大致分为如下三类：</p>
<ul>
<li>INNER JOIN（内连接或等值连接）：获取两个表中字段匹配关系的记录。</li>
<li>LEFT JOIN（左连接）：获取左表所有记录，即使右表没有对应匹配的记录。</li>
<li>RIGHT JOIN（右连接）： 与LEFT JOIN 相反，用于获取右表所有记录，即使左表没有对应匹配的记录。</li>
</ul>
<h5 id="NULL值处理"><a href="#NULL值处理" class="headerlink" title="NULL值处理"></a>NULL值处理</h5><p>MySQL 使用SQL SELECT 命令及WHERE 子句来读取数据表中的数据,但是当提供的查询条件字段为NULL 时，该命令可能就无法正常工作。<br>为了处理这种情况，MySQL提供了三大运算符:</p>
<ul>
<li>IS NULL: 当列的值是 NULL,此运算符返回true。</li>
<li>IS NOT NULL: 当列的值不为NULL, 运算符返回true。</li>
<li>&lt;&#x3D;&gt;: 比较操作符(不同于&#x3D;运算符),当比较的的两个值为NULL 时返回true。</li>
</ul>
<p><small><strong>关于NULL 的条件比较运算是比较特殊的。你不能使用&#x3D;NULL 或!&#x3D;NULL 在列中查找NULL 值 。</strong></small><br><small>在MySQL 中，NULL 值与任何其它值的比较（即使是NULL ）永远返回false，即NULL &#x3D; NULL 返回false 。</small></p>
<hr>

<h3 id="高级"><a href="#高级" class="headerlink" title="高级"></a>高级</h3><h4 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h4><p>MySQL 同样也支持其他正则表达式的匹配，MySQL 中使用REGEXP 操作符来进行正则表达式匹配。<br>REGEXP 操作符:</p>
<ul>
<li>^ :匹配输入字符串的开始位置。如果设置了RegExp 对象的Multiline 属性，^ 也匹配’\n’ 或’\r’ 之后的位置。</li>
<li>$ :匹配输入字符串的结束位置。如果设置了RegExp 对象的Multiline 属性，$ 也匹配’\n’ 或’\r’ 之前的位置。</li>
<li>. :匹配除”\n” 之外的任何单个字符。要匹配包括’\n’ 在内的任何字符，请使用象’[.\n]’ 的模式。</li>
<li>[…] :字符集合。匹配所包含的任意一个字符。例如，’[abc]’ 可以匹配”plain” 中的’a’。</li>
<li>[^…] :负值字符集合。匹配未包含的任意字符。例如，’[^abc]’ 可以匹配”plain” 中的’p’。</li>
<li>p1|p2|p3 :匹配p1 或p2 或p3。例如，’z|food’ 能匹配”z” 或”food”。’(z|f)ood’ 则匹配 “zood” 或 “food”。</li>
<li>* :匹配前面的子表达式零次或多次。例如，zo* 能匹配”z” 以及”zoo”。* 等价于{0,}。</li>
<li>+ :匹配前面的子表达式一次或多次。例如，zo+’ 能匹配”zo” 以及”zoo”，但不能匹配 “z”。+ 等价于 {1,}。</li>
<li>{n} :n 是一个非负整数。匹配确定的n 次。例如，’o{2}’ 不能匹配”Bob” 中的’o’，但是能匹配”food” 中的两个o。</li>
<li>{n,m} :m 和n 均为非负整数，其中n&lt;&#x3D;m。最少匹配n 次且最多匹配m 次。</li>
</ul>
<p>示例：<br>查找name字段中以’st’为开头的所有数据：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> name <span class="keyword">FROM</span> person_tbl <span class="keyword">WHERE</span> name REGEXP <span class="string">&#x27;^st&#x27;</span>;</span><br></pre></td></tr></table></figure>
<p> 查找name字段中以元音字符开头或以’ok’ 字符串结尾的所有数据：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> name <span class="keyword">FROM</span> person_tbl <span class="keyword">WHERE</span> name REGEXP <span class="string">&#x27;^[aeiou]|ok$&#x27;</span>;</span><br></pre></td></tr></table></figure>

<h4 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h4><p>MySQL 事务主要用于处理操作量大，复杂度高的数据。<br>事务是必须满足4个条件（ACID）:原子性（Atomicity，或称不可分割性）、一致性（Consistency）、隔离性（Isolation，又称独立性）、持久性（Durability）。</p>
<ul>
<li>原子性：一个事务（transaction）中的所有操作，要么全部完成，要么全部不完成，不会结束在中间某个环节。事务在执行过程中发生错误，会被回滚（Rollback）到事务开始前的状态，就像这个事务从来没有执行过一样。</li>
<li>一致性：在事务开始之前和事务结束以后，数据库的完整性没有被破坏。这表示写入的资料必须完全符合所有的预设规则，这包含资料的精确度、串联性以及后续数据库可以自发性地完成预定的工作。</li>
<li>隔离性：数据库允许多个并发事务同时对其数据进行读写和修改的能力，隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致。事务隔离分为不同级别，包括读未提交（Read uncommitted）、读提交（read committed）、可重复读（repeatable read）和串行化（Serializable）。</li>
<li>持久性：事务处理结束后，对数据的修改就是永久的，即便系统故障也不会丢失。</li>
</ul>
<h5 id="隔离级别"><a href="#隔离级别" class="headerlink" title="隔离级别"></a>隔离级别</h5><p>SQL标准中的四种隔离级别:</p>
<ul>
<li>**READ UNCOMMITED(未提交读)**：<ul>
<li>事务中的修改，即使没有提交，对其它事务也是可见的。</li>
<li>事务读取未提交的数据，称为脏读(Dirty READ )。</li>
<li>性能并不比其它级别好太多，但确少了很多好处，不推荐。</li>
</ul>
</li>
<li>**READ COMMITED(提交读)、不可重复读(nonrepeatable read)**：<ul>
<li>大多数数据库的默认级别，但MySQL 不是。</li>
<li>一个事务只能读取已提交的事务所做的修改，换句话说，一个事务从开始直到提交之前，所做的任何修改对其它事务都是不可见的。</li>
<li>可能会导致虚读，如事务A 两次读取数据，事务B在这之间修改了数据，这两次读取会有不一样的结果，即可读取其它事务的增删改。</li>
</ul>
</li>
<li>**REPEATABLE READ(可重复读)**：<ul>
<li>MySQL默认级别。</li>
<li>解决脏读问题，保证在同一个事务中多次读取同样记录的结果是一致的。</li>
<li>可能会导致幻读(Phantom Read )，事务A 读取并修改数据，事务B 也在该范围修改了数据(插入或删除)，事务A 再次读取该范围的数据，发现了幻行(Phantom Row )，即可读取其它事务的增删。</li>
</ul>
</li>
<li>**SERIALIZABLE(可串行化)**：<ul>
<li>最高级别的隔离级别，强制事务串行执行。</li>
<li>在读取的每一行数据上都加锁，导致大量的超时和锁争用问题。</li>
</ul>
</li>
</ul>
<h5 id="事务日志"><a href="#事务日志" class="headerlink" title="事务日志"></a>事务日志</h5><p>使用事务日志，存储引擎修改表数据，只需修改其内存拷贝，再将该行为记录到持久在硬盘的事务日志中。<br>大多数存储引擎的实现方案，修改数据需写两次磁盘(第一次为日志记录，第二次为数据)。<br>优点：</p>
<ul>
<li>提高事务的效率</li>
<li>速度快。采用追加方式，写日志的操作是磁盘一小块区域的顺序IO ，而不是多区域的随机IO 。</li>
</ul>
<h4 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h4><h5 id="读写锁"><a href="#读写锁" class="headerlink" title="读写锁"></a>读写锁</h5><p>共享锁（读锁）： 其他事务可以读，但不能写。<br>排他锁（写锁）： 其他事务不能读取，也不能写。</p>
<h5 id="锁粒度"><a href="#锁粒度" class="headerlink" title="锁粒度"></a>锁粒度</h5><p>MySQL 不同的存储引擎支持不同的锁机制，所有的存储引擎都以自己的方式显现了锁机制，服务器层完全不了解存储引擎中的锁实现：</p>
<ul>
<li>MyISAM 和 MEMORY 存储引擎采用的是表级锁（table-level locking）。</li>
<li>BDB 存储引擎采用的是页面锁（page-level locking），但也支持表级锁。</li>
<li>InnoDB 存储引擎既支持行级锁（row-level locking），也支持表级锁，但默认情况下是采用行级锁。</li>
<li>默认情况下，表锁和行锁都是自动获得的， 不需要额外的命令。</li>
</ul>
<p>但是在有的情况下，用户需要明确地进行锁表或者进行事务的控制，以便确保整个事务的完整性，这样就需要使用事务控制和锁定语句来完成。</p>
<h4 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h4><p><strong>MySQL索引</strong>的建立对于MySQL 的高效运行是很重要的，索引可以大大提高MySQL 的检索速度。<br>建立索引会占用磁盘空间的索引文件。<br>创建最基本的索引：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> INDEX indexName <span class="keyword">ON</span> mytable(username(length)); </span><br></pre></td></tr></table></figure>
<p> 删除索引：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> INDEX [indexName] <span class="keyword">ON</span> mytable; </span><br></pre></td></tr></table></figure>
<p> 创建唯一索引：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">UNIQUE</span> INDEX indexName <span class="keyword">ON</span> mytable(username(length)) </span><br></pre></td></tr></table></figure>
<p> 使用Alter 命令添加和删除索引：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> tbl_name <span class="keyword">ADD</span> INDEX index_name (column_list) # 添加普通索引，索引值可出现多次。</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> tbl_name <span class="keyword">ADD</span> <span class="keyword">UNIQUE</span> index_name (column_list) # 这条语句创建索引的值必须是唯一的（除了<span class="keyword">NULL</span>外，<span class="keyword">NULL</span>可能会出现多次）。</span><br></pre></td></tr></table></figure>
<p> 显示索引信息：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> INDEX <span class="keyword">FROM</span> table_name;</span><br></pre></td></tr></table></figure>

<h4 id="临时表"><a href="#临时表" class="headerlink" title="临时表"></a>临时表</h4><p>MySQL 临时表在我们需要保存一些临时数据时是非常有用的。临时表只在当前连接可见，当关闭连接时，MySQL 会自动删除表并释放所有空间。<br>创建临时表：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> TEMPORARY <span class="keyword">TABLE</span> table_name (column_name column_type);</span><br></pre></td></tr></table></figure>
<p> 删除临时表：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> table_name;</span><br></pre></td></tr></table></figure>

<h4 id="复制表"><a href="#复制表" class="headerlink" title="复制表"></a>复制表</h4><p>需要完全的复制MySQL 的数据表，包括表的结构、索引、默认值等。 如果仅仅使用CREATE TABLE … SELECT 命令，是无法实现的。<br>如何完整的复制MySQL数据表，步骤如下：</p>
<ul>
<li>使用SHOW CREATE TABLE 命令获取创建数据表(CREATE TABLE) 语句，该语句包含了原数据表的结构、索引等。</li>
<li>复制以下命令显示的SQL语句，修改数据表名，并执行SQL语句，通过以上命令 将完全的复制数据表结构。</li>
<li>想复制表的内容，可以使用 INSERT INTO … SELECT 语句来实现。</li>
</ul>
<h4 id="序列"><a href="#序列" class="headerlink" title="序列"></a>序列</h4><p>MySQL 序列是一组整数：1, 2, 3, …，由于一张数据表只能有一个字段自增主键， 如果想实现其他字段也实现自动增加，就可以使用MySQL 序列来实现。</p>
<ol>
<li><p>AUTO_INCREMENT<br>MySQL 中最简单使用序列的方法就是使用AUTO_INCREMENT 来定义列。</p>
</li>
<li><p>重值序列</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> table_name <span class="keyword">DROP</span> id;</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> table_name <span class="keyword">ADD</span> id <span class="type">INT</span> UNSIGNED <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT <span class="keyword">FIRST</span>, <span class="keyword">ADD</span> <span class="keyword">PRIMARY</span> KEY (id);</span><br></pre></td></tr></table></figure>
</li>
<li><p>设置序列开始值<br>在表创建成功后，通过以下语句来实现：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> table_name AUTO_INCREMENT <span class="operator">=</span> <span class="number">100</span>;</span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="SQL-注入"><a href="#SQL-注入" class="headerlink" title="SQL 注入"></a>SQL 注入</h4><p>通过网页获取用户输入的数据并将其插入一个MySQL 数据库，那么就有可能发生SQL 注入安全的问题。<br>所谓<strong>SQL 注入</strong>，就是通过把SQL 命令插入到Web 表单递交或输入域名或页面请求的查询字符串，最终达到欺骗服务器执行恶意的SQL 命令。<br>防止SQL注入，我们需要注意以下几个要点：</p>
<ul>
<li>永远不要<strong>信任用户的输入</strong>。对用户的输入进行校验，可以通过正则表达式或限制长度,对单引号和 双”-“进行转换等。</li>
<li>永远不要使用<strong>动态拼装sql</strong> ，可以使用参数化的sql 或者直接使用存储过程进行数据查询存取。</li>
<li>永远不要使用<strong>管理员权限的数据库连接</strong>，为每个应用使用单独的权限有限的数据库连接。</li>
<li>不要把<strong>机密信息</strong>直接存放，加密或者hash 掉密码和敏感的信息。</li>
<li>应用的<strong>异常信息</strong>应该给出尽可能少的提示，最好使用自定义的错误信息对原始错误信息进行包装</li>
<li>SQL 注入的检测方法一般采取<strong>辅助软件或网站平台</strong>来检测，软件一般采用SQL 注入检测工具jsky ，网站平台就有亿思网站安全平台检测工具MDCSOFT SCAN 等。</li>
</ul>
<h4 id="导入、导出数据"><a href="#导入、导出数据" class="headerlink" title="导入、导出数据"></a>导入、导出数据</h4><p>导出语句：</p>
<ul>
<li>基本导出<br>：MySQL 中你可以使用SELECT … INTO OUTFILE 语句来简单的导出数据到文本文件上。<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> runoob_tbl <span class="keyword">INTO</span> OUTFILE <span class="string">&#x27;/tmp/vgbh.txt&#x27;</span>;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> passwd <span class="keyword">INTO</span> OUTFILE <span class="string">&#x27;/tmp/runoob.txt&#x27;</span> FIELDS TERMINATED <span class="keyword">BY</span> <span class="string">&#x27;,&#x27;</span> ENCLOSED <span class="keyword">BY</span> <span class="string">&#x27;&quot;&#x27;</span> LINES TERMINATED <span class="keyword">BY</span> <span class="string">&#x27;\r\n&#x27;</span>; # 导出csv 格式</span><br></pre></td></tr></table></figure></li>
<li>mysqldump 导出数据：<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysqldump <span class="operator">-</span>u root <span class="operator">-</span>p \<span class="operator">-</span>\<span class="operator">-</span><span class="keyword">no</span><span class="operator">-</span><span class="keyword">create</span><span class="operator">-</span>info \<span class="operator">-</span>\<span class="operator">-</span>tab<span class="operator">=</span><span class="operator">/</span>tmp RUNOOB runoob_tbl # 原始数据</span><br><span class="line">mysqldump <span class="operator">-</span>u root <span class="operator">-</span>p vgbh table_name <span class="operator">&gt;</span> vgbh.txt # <span class="keyword">SQL</span> 格式数据</span><br></pre></td></tr></table></figure></li>
</ul>
<p>导入语句：</p>
<ul>
<li>MySQL 命令导入：<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql <span class="operator">-</span>uroot <span class="operator">-</span>p123456 <span class="operator">&lt;</span> vgbh.sql</span><br></pre></td></tr></table></figure></li>
<li>source 命令导入：<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">source <span class="operator">/</span>home<span class="operator">/</span>abc<span class="operator">/</span>vgbh.sql # 导入备份数据库</span><br></pre></td></tr></table></figure></li>
<li>LOAD DATA 导入数据<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LOAD DATA <span class="keyword">LOCAL</span> INFILE <span class="string">&#x27;vgbh.txt&#x27;</span> <span class="keyword">INTO</span> <span class="keyword">TABLE</span> table_name;</span><br></pre></td></tr></table></figure></li>
<li>使用mysqlimport 导入数据<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysqlimport <span class="operator">-</span>u root <span class="operator">-</span>p \<span class="operator">-</span>\<span class="operator">-</span><span class="keyword">local</span> database_name vgbh.txt # mysqlimport 使用简介请自查</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="运算符、函数"><a href="#运算符、函数" class="headerlink" title="运算符、函数"></a>运算符、函数</h4><p>MySQL 有很多<strong>内置函数</strong>，主要有以下分类：</p>
<ul>
<li>字符串函数。</li>
<li>数字函数。</li>
<li>日期函数。</li>
</ul>
<p><small>有使用需求的可以自查！</small><br>MySQL 的<strong>运算符</strong>及运算符的优先级，主要有以下几种运算符：</p>
<ul>
<li>算术运算符。(+、-、*、&#x2F;、%)</li>
<li>比较运算符。(&#x3D;、&lt;&gt;、!&#x3D;、&gt;、&lt;、&lt;&#x3D;、&gt;&#x3D;、BETWEEN、NOT BETWEEN、IN、NOTIN、&lt;&#x3D;&gt;、LIKE、REGEXP、IS NULL、IS NOT NULL)</li>
<li>逻辑运算符。(NOT、AND、OR、XOR)</li>
<li>位运算符。(&amp;、|、^、!、&lt;&lt;、&gt;&gt;)</li>
</ul>
<p><small>具体的运算符优先级在使用时可自查！</small></p>
<h4 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h4><p>MySQL 共有六种日志文件，分别是：</p>
<ul>
<li>重做日志(redo log)</li>
<li>回滚日志(undo log)</li>
<li>二进制日志(bin log)</li>
<li>错误日志(error log)</li>
<li>慢查询日志(slow query log)</li>
<li>一般查询日志(general log)</li>
<li>中继日志(relay log)</li>
</ul>
<p>其中重做日志和回滚日志与<strong>事务操作</strong>息息相关，二进制日志也与事务操作有一定的关系。</p>
<h5 id="重做日志"><a href="#重做日志" class="headerlink" title="重做日志"></a>重做日志</h5><ol>
<li>作用<br>确保事务的持久性。<br>防止在发生故障的时候，尚有<strong>脏页</strong>未写入磁盘，在重启MySQL 服务的时候，根据redo log 进行重做，从而达到事务的持久性这一特征。</li>
<li>内容<br>物理格式的日志，记录的是物理数据页面的修改信息，其中redo log 是顺序写入reod log file 的物理文件中去的。</li>
<li>产生时间<br>事务开始之后就产生redo log ，redo log 的落盘并不是随着事物的提交才写入的，而是在事务的执行过程中，便开始写入的redo log 文件中。</li>
<li>释放时间<br>当对应事务的脏页写入到磁盘中，redo log 的使命也就完成了，重做日志占用的空间就可以重用（被覆盖）。</li>
<li>物理文件<br>默认情况下，对应的物理文件位于数据库的data 目录下的ib_logfile1 &amp; ib_logfile2 。<br>innodb_log_group_home_dir 指定日志文件组所在的路径，默认 &#x2F; ，表示在数据库的数据目录下。<br>innodb_log_files_in_group 指定重做日志文件族中文件的数量，默认2 。<br>关于文件的大小和数量，由以下两个参数配置innodb_log_file_size 重做日志文件的大小。<br>innodb_mirrored_log_groups 指定了日志镜像文件组的数量，默认1 。</li>
<li>其他<br>即使事务没有提交，Innodb 存储引擎仍然每秒会将重做日志缓存刷新到重做日志文件。</li>
</ol>
<h5 id="回滚日志"><a href="#回滚日志" class="headerlink" title="回滚日志"></a>回滚日志</h5><ol>
<li>作用<br>保存了事务发生之前的数据的一个版本，可以用于回滚，同时可以提供多版本并发控制下的读(MVVC) ，也即<strong>非锁定读</strong>。</li>
<li>内容<br>逻辑格式的日志，在执行undo 的时候，仅仅是将数据从逻辑上恢复至事务之前的状态，而不是从物理页面上操作实现的，这一点市不同于redo log 的。</li>
<li>产生时间<br>事务开始之前，简单强势的版本生成undo log ，undo 也会产生redo 来保证undo log 的可靠性。</li>
<li>释放时间<br>当事务提交之后，undo log 并不能立马被删除。<br>而是被放入到了<strong>待清理的链表</strong>中，由purge 线程判断是否由其他事务在使用undo 段中表的上一个事务之前的版本信息，决定是否可以清理undo log 的日志空间。</li>
<li>物理文件<br>MySQL 5.6 之前，undo 表空间位于共享表空间的回滚段中，共享表空间的默认的名称是ibdata ，位于数据文件目录中。<br>MySQL 5.6 之后，undo 表空间可以配置为独立的文件，但是提前需要在配置文件中配置，完成数据库初始化后生效且不可改变undo log 文件的个数。<br>MySQL 5.7 之后的独立undo 表空间配置参数如下：</li>
</ol>
<ul>
<li>innodb_undo_directory &#x3D; &#x2F;data&#x2F;undospace&#x2F;  undo 独立表空间的存放目录</li>
<li>innodb_undo_log &#x3D; 128  回滚字段为128KB</li>
<li>innodb_undo_tablespace &#x3D; 4  指定有四个undo log 文件</li>
</ul>
<ol start="6">
<li>其他<br>undo 是在事务开始之前保存的被修改数据的一个版本，产生undo 日志的时候，同样会伴随类似于保护事务持久化机制的redo log 的产生。<br>默认情况下undo 文件是保持在共享表空间的，也即ibdatafile 文件中，当数据库中发生一些大的事务性操作时，要生成大量的undo 信息，全部保存在共享表空间中。<br>因此共享表空间会很大，默认情况下，被撑大的共享表空间是不会自动收缩的。</li>
</ol>
<h5 id="二进制日志"><a href="#二进制日志" class="headerlink" title="二进制日志"></a>二进制日志</h5><ol>
<li>作用<br>用于复制，在主从复制中，从库利用主库上的 bin log 进行重播，实现<strong>主从同步</strong>。<br>用于数据库的基于时间点的还原。</li>
<li>内容<br>逻辑格式的日志，可以认为是执行过的事务的sql 语句。但是又不是sql 语句，还包含了执行sql 语句的反向的信息。<br>因此可以基于bin log 做到类似与oracle 的闪回功能，其实都是依赖bin log 中的日志记录。</li>
<li>产生时间<br>事务提交的时候，一次性将事务中的sql 语句按照一定的格式记录到bin log 中去。<br>因此对于事务的提交，即便是较大的事务，提交都是很快的，但是在开启bin log 的时候，对于较大的事务，可能会变得比较慢一点。</li>
<li>释放时间<br>bin log 的默认保持时间是由<strong>参数expire_logs_days</strong> 配置，也就是说对于非活动的日志文件，在生成时间超过expire_logs_days 配置的时间后，会被自动删除。</li>
<li>物理文件<br>配置文件的路径为log_bin_basename ，bin log 日志文件按照指定大小，当达到指定的大小时，会进行滚动更新，生成新的日志文件。</li>
<li>其他<br>二进制日志的作用之一是还原数据库的，这与redo log 很类似，但还是有本质的区别：</li>
</ol>
<ul>
<li>作用不同。</li>
<li>内容不同。</li>
<li>释放时间不同。</li>
<li>恢复数据的效率也不同。</li>
</ul>
<p>最后，MySQL 通过两阶段的提交过程来完成事务的一致性，也即 redo log 和 bin log 的一致性，理论上先写 redo log，再写 bin log，两个日志都提交成功，事务才算是真正的完成。</p>
<h5 id="中继日志"><a href="#中继日志" class="headerlink" title="中继日志"></a>中继日志</h5><ol>
<li>作用<br>MySQL 进行主主复制或主从复制的时候会在配置文件制定的目录下面产生相应的 relay log。从服务器 I&#x2F;O 线程将主服务器的二进制日志（bin log）读取过来记录到从服务器本地文件，然后 SQL 线程会读取 relay log 日志的内容并应用到从服务器。<br><img src="https://i.loli.net/2021/04/24/h2itWYVNZTbvwDm.jpg" alt="31243e7d6299e4448257529b78f82072.jpg"></li>
</ol>
<hr>

<h3 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h3><h4 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h4><h5 id="框架"><a href="#框架" class="headerlink" title="框架"></a>框架</h5><p><a target="_blank" rel="noopener" href="https://i.loli.net/2019/07/22/5d3598f989bdb68702.jpg"><img src="https://i.loli.net/2019/07/22/5d3598f989bdb68702.jpg" alt="1.jpg"></a><br>第一层为客户端的连接认证，C&#x2F;S都有此架构。<br>第二层为服务器层，包含MySQL的大多数核心服务功能。<br>第三层包含了存储引擎，服务器通过API 与其通信，API 规避了不同存储引擎的差异，不同存储引擎也不会互相通信。另外存储引擎不会去解析SQL(InnoDB 是例外，它会解析外键定义，因为服务器本身没有实现该功能)。</p>
<h5 id="连接管理和安全"><a href="#连接管理和安全" class="headerlink" title="连接管理和安全"></a>连接管理和安全</h5><p>每个客户端在服务器进程中拥有一个线程。<br>服务器会负责缓存线程，不需要为每一个新建的连接创建或销毁线程(5.5以后版本提供了线程池，可使用少量线程来服务大量连接)。<br>服务器基于用户名、原始主机信息和密码对客户端进行认证，连接成功后会验证某个特定操作的权限。<br>​</p>
<h5 id="优化和执行"><a href="#优化和执行" class="headerlink" title="优化和执行"></a>优化和执行</h5><p>MySQL 会解析查询，创建内部数据结构(解析树)，并对其进行各种优化(重写查询、决定表的读取顺序、选择适合的索引)。<br>用户可以通过特殊的关键字提示(hint )优化器，影响MySQL 的决策过程。也可以请求优化器解释(explain )优化过程的各个因素，便于用户重构查询和schema ，修改相关配置。<br>优化器不关心表使用的存储引擎，但是存储引擎对优化查询有影响。优化器会请求存储引擎提供容量或某个具体操作的开销信息，已经表数据的统计信息等。<br>对于SELECT 语句，在解析查询前，服务器会先检查查询缓存(Query Cache)。</p>
<h4 id="存储引擎"><a href="#存储引擎" class="headerlink" title="存储引擎"></a>存储引擎</h4><h5 id="MyISAM"><a href="#MyISAM" class="headerlink" title="MyISAM"></a>MyISAM</h5><p>MySQL5.1及之前版本的默认存储引擎。支持全文索引、压缩、空间函数(GIS)，不支持事务和行级锁，并且崩溃后无法安全恢复。<br>对于只读数据，或者表比较小，可以忍受修复(repair )操作，可以考虑MyISAM。<br>存储：表以.MYD 和.MYI 的数据文件和索引文件存储在文件系统。<br>特性：</p>
<ul>
<li>加锁与并发: 对整张表而不是特定行加锁。读取时对读到的表加共享锁，写入时则加排它锁。支持并发插入(CONCURRENT INSERT )，在读取查询的同时，也可以插入新的数据。</li>
<li>修复: 与事务恢复以及崩溃恢复是不同的概念。速度慢，可能会导致数据丢失。通过CHECK TABLE mytable 检查表的错误，REPAIR TABLE mytable 进行修复。</li>
<li>索引特性: 支持全文索引，这是基于分词创建的索引。即使是BOLB 和TEXT 等长字段，也可以基于前500个字符创建索引。</li>
<li>延迟更新索引键(Delayed Key Write): 如指定了DELAY_KEY_WRITE ，每次修改执行完成时，不会将修改的索引数据写入磁盘而是写到内存中的键缓存区(in-memory key buffer)，只有在清理键缓存区或关闭表的时候才会写入磁盘。可极大提升写入性能，但可能在数据库或主机崩溃时造成索引损坏而执行修复操作。</li>
</ul>
<p>压缩表：只进行读操作可采用压缩表，极大减少磁盘占用空间以及IO ，从而提升查询性能。<br>性能：设计简单，数据以紧密格式存储，在某些场景下的性能很好。最典型的性能问题为表锁。</p>
<h5 id="InnoDB"><a href="#InnoDB" class="headerlink" title="InnoDB"></a>InnoDB</h5><p>MySQL 默认事务型存储引擎，拥有良好的性能和自动崩溃恢复特性。<br>设计目的：处理大量的短期(short-lived )事务(短期事务大部分情况是正常提交的，很少被回滚)。<br>概览：</p>
<ul>
<li>数据存储在表空间(tablespace )中，由InnoDB 管理的黑盒子，有一系列的数据文件组成。</li>
<li>采用MVVC 支持高并发，实现四个标准的隔离级别，默认为REPEATABLE READ ，并且通过间隙锁(next-key locking )策略使得InnoDB 锁定查询涉及的行，还会对索引中的间隙进行锁定，防止幻读出现。</li>
<li>基于聚簇索引建立，对主键查询有很高的性能。但是二级索引(secondary index ，非主键索引)必须包含主键列。如主键索引过大，其它的所有索引都会很大。</li>
<li>从磁盘读取数据采用可预测性预读、自动在内存中创建hash 索引以加速读操作的自适应索引(adaptive hash index )，加速插入操作的插入缓冲区(insert buffer )。</li>
<li>通过一些机制和工具支持真正的热备份。</li>
</ul>
<h5 id="MyISAM-与InnoDB-对比"><a href="#MyISAM-与InnoDB-对比" class="headerlink" title="MyISAM 与InnoDB 对比"></a>MyISAM 与InnoDB 对比</h5><p>MyISAM 更适合读密集的表，而InnoDB更适合写密集的表。<br>因此在数据库做到主从分离、读写分离之后，为了进一步的提高数据库的性能，可以考虑读取频率较高的库使用MyISAM 作为读取存储引擎，那么写入频率较高的库可以使用InnoDB 作为写入存储引擎。</p>
<h5 id="其他引擎"><a href="#其他引擎" class="headerlink" title="其他引擎"></a>其他引擎</h5><ol>
<li>Archive 引擎：非事务型对告诉插入和压缩做优化的引擎。支持INSERT、SELECT 和索引，每次SELECT 都需要全表扫描，并阻止其它SELECT 执行，以实现一致性读。支持行级锁和专用缓冲区，实现高并发插入。适合日志和数据采集类应用。</li>
<li>Blackhole 引擎：没有实现任何的存储机制，因为它丢弃所有插入的数据，不做保存，但是服务器会记录Blackhole 表的日志，所以可以用于复制数据到备库，或者简单地记录到日志。适合特殊的复制架构和日志审核，但并不推荐。</li>
<li>CSV 引擎：将CSV 文件作为MySQL 表来处理，但不支持索引。适合作为一种数据交换的机制。</li>
<li>Federated 引擎：访问其它MySQL 服务器的代理，创建一个远程MySQL 的客户端连接，将查询传到远程服务器执行，然后提取或发送需要的数据。</li>
<li>Memory 引擎：</li>
</ol>
<ul>
<li>所有数据保存在内存中，不需要磁盘IO ，比MyISAM 快一个数量级。</li>
<li>支持Hash索引，但是是表级锁，因此并发写入性能低</li>
<li>不支持BOLB 和TEXT 的列，并且每行的长度是固定的。</li>
<li>适合快速地访问数据，并且这些数据不会修改，重启以后丢失也没关系(数据会丢失，表结构仍保留)。</li>
</ul>
<ol start="6">
<li>Merge引擎：弃用。</li>
<li>NDB集群引擎：参加MySQL 集群。</li>
</ol>
<h4 id="规范"><a href="#规范" class="headerlink" title="规范"></a>规范</h4><h5 id="命令规范"><a href="#命令规范" class="headerlink" title="命令规范"></a>命令规范</h5><p>所有数据库对象名称必须使用小写字母并用下划线分割。<br>所有数据库对象名称禁止使用 mysql 保留关键字。（如果表名中包含关键字查询时，需要将其用单引号括起来）<br>数据库对象的命名要能做到见名识意，并且最后不要超过 32 个字符。<br>临时库表必须以 tmp_ 为前缀并以日期为后缀，备份表必须以 bak_ 为前缀并以日期(时间戳)为后缀。<br>所有存储相同数据的列名和列类型必须一致。（一般作为关联列，如果查询时关联列类型不一致会自动进行数据类型隐式转换，会造成列上的索 引失效，导致查询效率降低）</p>
<h5 id="基本设计规范"><a href="#基本设计规范" class="headerlink" title="基本设计规范"></a>基本设计规范</h5><ol>
<li><p>所有表必须使用 Innodb 存储引擎<br>没有特殊要求（即 Innodb 无法满足的功能如：列存储，存储空间数据等）的情况下，所有表必须使用 Innodb 存储引擎（mysql5.5之前默认使用Myisam，5.6以后默认的为Innodb）Innodb 支持事务，支持行级锁，更好的恢复性，高并发下性能更好</p>
</li>
<li><p>数据库和表的字符集统一使用UTF8<br>兼容性更好，统一字符集可以避免由于字符集转换产生的乱码，不同的字符集进行比较前需要进行转换会造成索引失效</p>
</li>
<li><p>所有表和字段都需要添加注释<br>使用comment从句添加表和列的备注 从一开始就进行数据字典的维护</p>
</li>
<li><p>尽量控制单表数据量的大小，建议控制在500万以内<br>500万并不是MySQL数据库的限制，过大会造成修改表结构，备份，恢复都会有很大的问题<br>可以用历史数据归档（应用于日志数据），分库分表（应用于业务数据）等手段来控制数据量大小</p>
</li>
<li><p>谨慎使用MySQL分区表<br>分区表在物理上表现为多个文件，在逻辑上表现为一个表 谨慎选择分区键，跨分区查询效率可能更低 建议采用物理分表的方式管理大数据</p>
</li>
<li><p>尽量做到冷热数据分离，减小表的宽度<br>MySQL限制每个表最多存储4096列，并且每一行数据的大小不能超过65535字节 减少磁盘IO,保证热数据的内存缓存命中率（表越宽，把表装载进内存缓冲池时所占用的内存也就越大,也会消耗更多的IO） 更有效的利用缓存，避免读入无用的冷数据 经常一起使用的列放到一个表中（避免更多的关联操作）</p>
</li>
<li><p>禁止在表中建立预留字段<br>预留字段的命名很难做到见名识义 预留字段无法确认存储的数据类型，所以无法选择合适的类型 对预留字段类型的修改，会对表进行锁定</p>
</li>
<li><p>禁止在数据库中存储图片，文件等大的二进制数据<br>通常文件很大，会短时间内造成数据量快速增长，数据库进行数据库读取时，通常会进行大量的随机IO 操作，文件很大时，IO 操作很耗时 通常存储于文件服务器，数据库只存储文件地址信息</p>
</li>
<li><p>禁止在线上做数据库压力测试</p>
</li>
<li><p>禁止从开发环境，测试环境直接连接生成环境数据库</p>
</li>
</ol>
<h5 id="字段设计规范"><a href="#字段设计规范" class="headerlink" title="字段设计规范"></a>字段设计规范</h5><ol>
<li><p>优先选择符合存储需要的最小的数据类型<br>列的字段越大，建立索引时所需要的空间也就越大，这样一页中所能存储的索引节点的数量也就越少也越少，在遍历时所需要的IO 次数也就越多，索引的性能也就越差。</p>
</li>
<li><p>避免使用TEXT、BLOB数据类型，最常见的TEXT类型可以存储64k的数据</p>
</li>
</ol>
<ul>
<li>建议把BLOB或是TEXT列分离到单独的扩展表中<br>Mysql内存临时表不支持TEXT、BLOB这样的大数据类型，如果查询中包含这样的数据，在排序等操作时，就不能使用内存临时表，必须使用磁盘临时表进行。<br>而且对于这种数据，Mysql还是要进行二次查询，会使sql性能变得很差，但是不是说一定不能使用这样的数据类型。<br>如果一定要使用，建议把BLOB或是TEXT列分离到单独的扩展表中，查询时一定不要使用select * 而只需要取出必要的列，不需要TEXT列的数据时不要对该列进行查询。</li>
<li>TEXT或BLOB类型只能使用前缀索引<br>因为MySQL对索引字段长度是有限制的，所以TEXT类型只能使用前缀索引，并且TEXT列上是不能有默认值的。</li>
</ul>
<ol start="3">
<li>避免使用ENUM类型</li>
</ol>
<ul>
<li>修改ENUM值需要使用ALTER语句</li>
<li>ENUM类型的ORDER BY操作效率低，需要额外操作</li>
<li>禁止使用数值作为ENUM的枚举值</li>
</ul>
<ol start="4">
<li>尽可能把所有列定义为NOT NULL</li>
</ol>
<ul>
<li>索引NULL列需要额外的空间来保存，所以要占用更多的空间；</li>
<li>进行比较和计算时要对NULL值做特别的处理</li>
</ul>
<ol start="5">
<li>使用TIMESTAMP（4个字节）或DATETIME类型（8个字节）存储时间<br>TIMESTAMP 存储的时间范围 1970-01-01 00:00:01 ~ 2038-01-19-03:14:07。<br>TIMESTAMP 占用4字节和INT相同，但比INT可读性高<br>超出TIMESTAMP取值范围的使用DATETIME类型存储。<br>经常会有人用字符串存储日期型的数据（不正确的做法）：</li>
</ol>
<ul>
<li>缺点1：无法用日期函数进行计算和比较</li>
<li>缺点2：用字符串存储日期要占用更多的空间</li>
</ul>
<ol start="6">
<li>同财务相关的金额类数据必须使用decimal类型</li>
</ol>
<ul>
<li>非精准浮点：float,double</li>
<li>精准浮点：decimal<br>Decimal类型为精准浮点数，在计算时不会丢失精度。占用空间由定义的宽度决定，每4个字节可以存储9位数字，并且小数点要占用一个字节。可用于存储比bigint更大的整型数据。</li>
</ul>
<h5 id="索引设计规范"><a href="#索引设计规范" class="headerlink" title="索引设计规范"></a>索引设计规范</h5><ol>
<li><p>限制每张表上的索引数量，建议单张表索引不超过5个<br>索引并不是越多越好！索引可以提高效率同样可以降低效率。<br>索引可以增加查询效率，但同样也会降低插入和更新的效率，甚至有些情况下会降低查询效率。<br>因为mysql优化器在选择如何优化查询时，会根据统一信息，对每一个可以用到的索引来进行评估，以生成出一个最好的执行计划，如果同时有很多个索引都可以用于查询，就会增加mysql优化器生成执行计划的时间，同样会降低查询性能。</p>
</li>
<li><p>禁止给表中的每一列都建立单独的索引<br>5.6版本之前，一个sql只能使用到一个表中的一个索引，5.6以后，虽然有了合并索引的优化方式，但是还是远远没有使用一个联合索引的查询方式好</p>
</li>
<li><p>每个Innodb表必须有个主键<br>Innodb是一种索引组织表：数据的存储的逻辑顺序和索引的顺序是相同的。<br>每个表都可以有多个索引，但是表的存储顺序只能有一种 Innodb是按照主键索引的顺序来组织表的。<br>不要使用更新频繁的列作为主键，不适用多列主键（相当于联合索引） 不要使用UUID、MD5、HASH、字符串列作为主键（无法保证数据的顺序增长）。<br>主键建议使用自增ID值。</p>
</li>
</ol>
<h5 id="索引列建议"><a href="#索引列建议" class="headerlink" title="索引列建议"></a>索引列建议</h5><p>出现在SELECT、UPDATE、DELETE语句的WHERE从句中的列</p>
<ul>
<li>包含在ORDER BY、GROUP BY、DISTINCT中的字段<br>并不要将符合1和2中的字段的列都建立一个索引，通常将1、2中的字段建立联合索引效果更好</li>
<li>多表join的关联列</li>
</ul>
<h5 id="选择索引列的顺序"><a href="#选择索引列的顺序" class="headerlink" title="选择索引列的顺序"></a>选择索引列的顺序</h5><p>建立索引的目的是：希望通过索引进行数据查找，减少随机IO，增加查询性能 ，索引能过滤出越少的数据，则从磁盘中读入的数据也就越少。</p>
<ul>
<li>区分度最高的放在联合索引的最左侧（区分度&#x3D;列中不同值的数量&#x2F;列的总行数）；</li>
<li>尽量把字段长度小的列放在联合索引的最左侧（因为字段长度越小，一页能存储的数据量越大，IO性能也就越好）；</li>
<li>使用最频繁的列放到联合索引的左侧（这样可以比较少的建立一些索引）。</li>
</ul>
<h5 id="建立冗余索引和重复索引"><a href="#建立冗余索引和重复索引" class="headerlink" title="建立冗余索引和重复索引"></a>建立冗余索引和重复索引</h5><p>因为这样会增加查询优化器生成执行计划的时间。</p>
<ul>
<li>重复索引示例：primary key(id)、index(id)、unique index(id)</li>
<li>冗余索引示例：index(a,b,c)、index(a,b)、index(a)</li>
</ul>
<h5 id="考虑覆盖索引"><a href="#考虑覆盖索引" class="headerlink" title="考虑覆盖索引"></a>考虑覆盖索引</h5><p>对于频繁的查询优先考虑使用覆盖索引。<br>覆盖索引：就是包含了所有查询字段(where、select、ordery by、group by 包含的字段)的索引。<br>覆盖索引的好处：</p>
<ul>
<li>避免Innodb表进行索引的二次查询<br>Innodb是以聚集索引的顺序来存储的，对于Innodb 来说，二级索引在叶子节点中所保存的是行的主键信息。<br>如果是用二级索引查询数据的话，在查找到相应的键值后，还要通过主键进行二次查询才能获取我们真实所需要的数据。而在覆盖索引中，二级索引的键值中可以获取所有的数据，避免了对主键的二次查询 ，减少了IO操作，提升了查询效率。</li>
<li>可以把随机IO变成顺序IO加快查询效率<br>由于覆盖索引是按键值的顺序存储的，对于IO密集型的范围查找来说，对比随机从磁盘读取每一行的数据IO要少的多，因此利用覆盖索引在访问时也可以把磁盘的随机读取的IO转变成索引查找的顺序IO。</li>
</ul>
<h5 id="索引SET-规范"><a href="#索引SET-规范" class="headerlink" title="索引SET 规范"></a>索引SET 规范</h5><p>尽量避免使用外键约束</p>
<ul>
<li>不建议使用外键约束（foreign key），但一定要在表与表之间的关联键上建立索引；</li>
<li>外键可用于保证数据的参照完整性，但建议在业务端实现；</li>
<li>外键会影响父表和子表的写操作从而降低性能。</li>
</ul>
<h5 id="SQL-开发规范"><a href="#SQL-开发规范" class="headerlink" title="SQL 开发规范"></a>SQL 开发规范</h5><ol>
<li><p>建议使用预编译语句进行数据库操作<br>预编译语句可以重复使用这些计划，减少SQL编译所需要的时间，还可以解决动态SQL所带来的SQL注入的问题 只传参数，比传递SQL语句更高效 相同语句可以一次解析，多次使用，提高处理效率。</p>
</li>
<li><p>避免数据类型的隐式转换<br>隐式转换会导致索引失效。如：select name,phone from customer where id &#x3D; ‘111’;</p>
</li>
<li><p>充分利用表上已经存在的索引</p>
</li>
</ol>
<ul>
<li>避免使用双%号的查询条件。</li>
<li>一个SQL只能利用到复合索引中的一列进行范围查询。</li>
<li>使用left join或 not exists来优化not in 操作，因为not in 也通常会使用索引失效。</li>
</ul>
<ol start="4">
<li><p>数据库设计时，应该要对以后扩展进行考虑</p>
</li>
<li><p>程序连接不同的数据库使用不同的账号，进制跨库查询</p>
</li>
</ol>
<ul>
<li>为数据库迁移和分库分表留出余地</li>
<li>降低业务耦合度</li>
<li>避免权限过大而产生的安全风险</li>
</ul>
<ol start="6">
<li>禁止使用SELECT * 必须使用SELECT &lt;字段列表&gt; 查询</li>
</ol>
<ul>
<li>消耗更多的CPU和IO以网络带宽资源</li>
<li>无法使用覆盖索引</li>
<li>可减少表结构变更带来的影响</li>
</ul>
<ol start="7">
<li><p>禁止使用不含字段列表的INSERT 语句<br>例如：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="keyword">values</span> (<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>);</span><br></pre></td></tr></table></figure>
<p> 应使用:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t(c1,c2,c3) <span class="keyword">values</span> (<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p>避免使用子查询，可以把子查询优化为join 操作<br>通常子查询在in子句中，且子查询中为简单SQL(不包含union、group by、order by、limit 从句)时，才可以把子查询转化为关联查询进行优化。<br>子查询性能差的原因：</p>
</li>
</ol>
<ul>
<li>子查询的结果集无法使用索引，通常子查询的结果集会被存储到临时表中，不论是内存临时表还是磁盘临时表都不会存在索引，所以查询性能 会受到一定的影响；</li>
<li>特别是对于返回结果集比较大的子查询，其对查询性能的影响也就越大；</li>
<li>由于子查询会产生大量的临时表也没有索引，所以会消耗过多的CPU和IO资源，产生大量的慢查询。</li>
</ul>
<ol start="9">
<li><p>避免使用JOIN关联太多的表<br>对于Mysql来说，是存在关联缓存的，缓存的大小可以由join_buffer_size参数进行设置。<br>在Mysql中，对于同一个SQL多关联（join）一个表，就会多分配一个关联缓存，如果在一个SQL中关联的表越多，所占用的内存也就越大。<br>如果程序中大量的使用了多表关联的操作，同时join_buffer_size设置的也不合理的情况下，就容易造成服务器内存溢出的情况，就会影响到服务器数据库性能的稳定性。<br>同时对于关联操作来说，会产生临时表操作，影响查询效率Mysql最多允许关联61个表，建议不超过5个。</p>
</li>
<li><p>减少同数据库的交互次数<br>数据库更适合处理批量操作 合并多个相同的操作到一起，可以提高处理效率</p>
</li>
<li><p>对应同一列进行or 判断时，使用in 代替or<br>in 的值不要超过500个in 操作可以更有效的利用索引，or 大多数情况下很少能利用到索引。</p>
</li>
<li><p>禁止使用order by rand() 进行随机排序<br>会把表中所有符合条件的数据装载到内存中，然后在内存中对所有数据根据随机生成的值进行排序，并且可能会对每一行都生成一个随机值，如果满足条件的数据集非常大，就会消耗大量的CPU和IO及内存资源。<br>推荐在程序中获取一个随机值，然后从数据库中获取数据的方式。</p>
</li>
<li><p>WHERE从句中禁止对列进行函数转换和计算<br>对列进行函数转换或计算时会导致无法使用索引。</p>
</li>
</ol>
<ul>
<li>不推荐：<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">where</span> data(create_time) <span class="operator">=</span> <span class="string">&#x27;20190806&#x27;</span></span><br></pre></td></tr></table></figure></li>
<li>推荐：<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">where</span> create_time <span class="operator">&gt;=</span> <span class="string">&#x27;20190806&#x27;</span> <span class="keyword">and</span> create_time <span class="operator">&lt;</span> <span class="string">&#x27;20190807&#x27;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<ol start="14">
<li>在明显不会有重复值时使用UNION ALL而不是UNION</li>
</ol>
<ul>
<li>UNION会把两个结果集的所有数据放到临时表中后再进行去重操作</li>
<li>UNION ALL不会再对结果集进行去重操作</li>
</ul>
<ol start="15">
<li>拆分复杂的大SQL为多个小SQL</li>
</ol>
<ul>
<li>大SQL：逻辑上比较复杂，需要占用大量CPU进行计算的SQL</li>
<li>MySQL：一个SQL只能使用一个CPU进行计算</li>
<li>SQL拆分后可以通过并行执行来提高处理效率</li>
</ul>
<h5 id="操作行为规范"><a href="#操作行为规范" class="headerlink" title="操作行为规范"></a>操作行为规范</h5><ol>
<li>超100万行的批量写（UPDATE、DELETE、INSERT）操作，要分批多次进行操作</li>
</ol>
<ul>
<li>大批量操作可能会造成严重的主从延迟<br>主从环境中，大批量操作可能会造成严重的主从延迟，大批量的写操作一般都需要执行一定长的时间，而只有当主库上执行完成后，才会在其他从库上执行，所以会造成主库与从库长时间的延迟情况</li>
<li>binlog日志为row格式时会产生大量的日志<br>大批量写操作会产生大量日志，特别是对于row格式二进制数据而言，由于在row格式中会记录每一行数据的修改，我们一次修改的数据越多，产生的日志量也就会越多，日志的传输和恢复所需要的时间也就越长，这也是造成主从延迟的一个原因。</li>
<li>避免产生大事务操作<br>大批量修改数据，一定是在一个事务中进行的，这就会造成表中大批量数据进行锁定，从而导致大量的阻塞，阻塞会对MySQL的性能产生非常大的影响。<br>特别是长时间的阻塞会占满所有数据库的可用连接，这会使生产环境中的其他应用无法连接到数据库，因此一定要注意大批量写操作要进行分批。</li>
</ul>
<ol start="2">
<li>对于大表使用pt-online-schema-change修改表结构</li>
</ol>
<ul>
<li>避免大表修改产生的主从延迟</li>
<li>避免在对表字段进行修改时进行锁表<br>对大表数据结构的修改一定要谨慎，会造成严重的锁表操作，尤其是生产环境，是不能容忍的。<br>pt-online-schema-change它会首先建立一个与原表结构相同的新表，并且在新表上进行表结构的修改，然后再把原表中的数据复制到新表中，并在原表中增加一些触发器。<br>把原表中新增的数据也复制到新表中，在行所有数据复制完成之后，把新表命名成原表，并把原来的表删除掉。<br>把原来一个DDL操作，分解成多个小的批次进行。</li>
</ul>
<ol start="3">
<li><p>禁止为程序使用的账号赋予super权限<br>当达到最大连接数限制时，还运行1个有super权限的用户连接super权限只能留给DBA处理问题的账号使用。</p>
</li>
<li><p>对于程序连接数据库账号，遵循权限最小原则<br>程序使用数据库账号只能在一个DB下使用，不准跨库 程序使用的账号原则上不准有 drop 权限。</p>
</li>
</ol>
<h4 id="语法优化"><a href="#语法优化" class="headerlink" title="语法优化"></a>语法优化</h4><ol>
<li><p>在查询时，避免全表查询，应当使用where或者order by 上所涉及的列建立索引。<br>索引是对数据库表中一列或多列的值进行排序的一种结构，使用索引可快速访问数据库表中的特定信息。<br>索引的一个主要目的就是加快检索表中数据的方法，亦即能协助信息搜索者尽快的找到符合限制条件的记录ID的辅助数据结构。</p>
</li>
<li><p>在查询时，避免使用!&#x3D;或者&lt;&gt;，这类的运算符会避开索引对全表进行查找。</p>
</li>
<li><p>避免使用null值进行判断查找数据，这样会遍历整个表。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> age <span class="operator">=</span> <span class="keyword">null</span>;</span><br></pre></td></tr></table></figure>
<p> 为避免这种情况，可以设置默认值为0。</p>
</li>
<li><p>避免在sql查询语句中添加or。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">1</span> <span class="keyword">or</span> <span class="number">1</span> <span class="operator">=</span> <span class="number">1</span>;  </span><br></pre></td></tr></table></figure>
</li>
<li><p>下面的查询也将导致全表扫描：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> id <span class="keyword">from</span> t <span class="keyword">where</span> name <span class="keyword">like</span> <span class="string">&#x27;%abc%&#x27;</span></span><br></pre></td></tr></table></figure>
<p> 若要提高效率，可以考虑全文检索。</p>
</li>
<li><p>in和not in 也要慎用，否则会导致全表扫描，如：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> id <span class="keyword">from</span> t <span class="keyword">where</span> num <span class="keyword">in</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)</span><br></pre></td></tr></table></figure>
<p> 对于连续的数值，能用between 就不要用in 。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> id <span class="keyword">from</span> t <span class="keyword">where</span> num <span class="keyword">between</span> <span class="number">1</span> <span class="keyword">and</span> <span class="number">3</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>如果在where 子句中使用参数，也会导致全表扫描。<br>因为SQL 只有在运行时才会解析局部变量，但优化程序不能将访问计划的选择推迟到运行时，它必须在编译时进行选择。<br>然而，如果在编译时建立访问计划，变量的值还是未知的，因而无法作为索引选择的输入项。<br>如下面语句将进行全表扫描：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> id <span class="keyword">from</span> t <span class="keyword">where</span> num<span class="operator">=</span><span class="variable">@num</span></span><br></pre></td></tr></table></figure>
<p> 可以改为强制查询使用索引：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> id <span class="keyword">from</span> t <span class="keyword">with</span>(index(索引名)) <span class="keyword">where</span> num<span class="operator">=</span><span class="variable">@num</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>应尽量<strong>避免在 where 子句中对字段进行表达式操作</strong>，这将导致引擎放弃使用索引而进行全表扫描。如：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> id <span class="keyword">from</span> t <span class="keyword">where</span> num<span class="operator">/</span><span class="number">2</span><span class="operator">=</span><span class="number">100</span></span><br></pre></td></tr></table></figure>
<p> 应改为:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> id <span class="keyword">from</span> t <span class="keyword">where</span> num<span class="operator">=</span><span class="number">100</span>\<span class="operator">*</span><span class="number">2</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>应尽量<strong>避免在where子句中对字段进行函数操作</strong>，这将导致引擎放弃使用索引而进行全表扫描。如：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> id <span class="keyword">from</span> t <span class="keyword">where</span> <span class="built_in">substring</span>(name,<span class="number">1</span>,<span class="number">3</span>)<span class="operator">=</span><span class="string">&#x27;abc&#x27;</span><span class="comment">--name以abc开头的id</span></span><br><span class="line"><span class="keyword">select</span> id <span class="keyword">from</span> t <span class="keyword">where</span> datediff(<span class="keyword">day</span>,createdate,<span class="string">&#x27;2005-11-30&#x27;</span>)<span class="operator">=</span><span class="number">0</span><span class="comment">--&#x27;2005-11-30&#x27;生成的id</span></span><br></pre></td></tr></table></figure>
<p> 应改为:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> id <span class="keyword">from</span> t <span class="keyword">where</span> name <span class="keyword">like</span> <span class="string">&#x27;abc%&#x27;</span></span><br><span class="line"><span class="keyword">select</span> id <span class="keyword">from</span> t <span class="keyword">where</span> createdate<span class="operator">&gt;=</span><span class="string">&#x27;2005-11-30&#x27;</span> <span class="keyword">and</span> createdate<span class="operator">&lt;</span><span class="string">&#x27;2005-12-1&#x27;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>不要在where 子句中的 &#x3D; 左边进行函数、算术运算或其他表达式运算，否则系统将可能无法正确使用索引。</strong></p>
</li>
<li><p>在使用索引字段作为条件时，如果该索引是复合索引，那么必须使用到该索引中的第一个字段作为条件时才能保证系统使用该索引，否则该索引将不会被使用，并且应尽可能的让字段顺序与索引顺序相一致。</p>
</li>
<li><p>不要写一些没有意义的查询，如需要生成一个空表结构：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> col1,col2 <span class="keyword">into</span> t <span class="keyword">from</span> t <span class="keyword">where</span> <span class="number">1</span><span class="operator">=</span><span class="number">0</span></span><br></pre></td></tr></table></figure>
<p> 这类代码不会返回任何结果集，但是会消耗系统资源的，应改成这样：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> #t(...)</span><br></pre></td></tr></table></figure>
</li>
<li><p>很多时候用 exists 代替 in 是一个好的选择：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> num <span class="keyword">from</span> a <span class="keyword">where</span> num <span class="keyword">in</span>(<span class="keyword">select</span> num <span class="keyword">from</span> b)</span><br></pre></td></tr></table></figure>
<p> 用下面的语句替换：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> num <span class="keyword">from</span> a <span class="keyword">where</span> <span class="keyword">exists</span>(<span class="keyword">select</span> <span class="number">1</span> <span class="keyword">from</span> b <span class="keyword">where</span> num<span class="operator">=</span>a.num)</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用SQL 代码前，可以先使用<strong>Explain</strong> 检测一下SQL 代码性能。</p>
</li>
</ol>
<h4 id="结构优化"><a href="#结构优化" class="headerlink" title="结构优化"></a>结构优化</h4><ol>
<li><p>并不是所有<strong>索引</strong>对查询都有效，SQL 是根据表中数据来进行查询优化的，当索引列有大量数据重复时，SQL 查询可能不会去利用索引，如一表中有字段sex、male、female 几乎各一半，那么即使在sex 上建了索引也对查询效率起不了作用。</p>
</li>
<li><p>索引并不是越多越好，索引固然可以提高相应的 select 的效率，但同时也降低了 insert 及 update 的效率，因为 insert 或 update 时有可能会重建索引，所以怎样建索引需要慎重考虑，视具体情况而定。<strong>一个表的索引数最好不要超过6个，若太多则应考虑一些不常使用到的列上建的索引是否有必要。</strong></p>
</li>
<li><p>应尽可能的<strong>避免更新 clustered 索引数据列</strong>，因为 clustered 索引数据列的顺序就是表记录的物理存储顺序，一旦该列值改变将导致整个表记录的顺序的调整，会耗费相当大的资源。<br>若应用系统需要频繁更新 clustered 索引数据列，那么需要考虑是否应将该索引建为 clustered 索引。</p>
</li>
<li><p><strong>尽量使用数字型字段</strong>，若只含数值信息的字段尽量不要设计为字符型，这会降低查询和连接的性能，并会增加存储开销。<br>这是因为引擎在处理查询和连接时会逐个比较字符串中每一个字符，而对于数字型而言只需要比较一次就够了。</p>
</li>
<li><p>尽可能的使用 <code>varchar/nvarchar</code> 代替 <code>char/nchar</code> ，因为首先变长字段存储空间小，可以节省存储空间，其次对于查询来说，在一个相对较小的字段内搜索效率显然要高些。</p>
</li>
<li><p>任何地方都不要使用 <strong>select * from t</strong> ，用具体的字段列表代替 * ，不要返回用不到的任何字段。</p>
</li>
<li><p>尽量使用表变量来代替<strong>临时表</strong>。如果表变量包含大量数据，请注意索引非常有限（只有主键索引）。</p>
</li>
<li><p>避免频繁创建和删除临时表，以减少系统表资源的消耗。</p>
</li>
<li><p>临时表并不是不可使用，适当地使用它们可以使某些例程更有效，例如，当需要重复引用大型表或常用表中的某个数据集时。但是，对于一次性事件，最好使用导出表。</p>
</li>
<li><p>在新建临时表时，如果一次性插入数据量很大，那么可以使用 select into 代替 create table，避免造成大量 log ，以提高速度，如果数据量不大，为了缓和系统表的资源，应先create table，然后insert。</p>
</li>
<li><p>如果使用到了临时表，在存储过程的最后务必将所有的临时表显式删除，先 truncate table ，然后 drop table ，这样可以避免系统表的较长时间锁定。</p>
</li>
<li><p>尽量<strong>避免使用游标</strong>，因为游标的效率较差，如果游标操作的数据超过1万行，那么就应该考虑改写。</p>
</li>
<li><p>使用基于游标的方法或临时表方法之前，应先寻找基于集的解决方案来解决问题，基于集的方法通常更有效。</p>
</li>
<li><p>与临时表一样，游标并不是不可使用。对小型数据集使用 FAST_FORWARD 游标通常要优于其他逐行处理方法，尤其是在必须引用几个表才能获得所需的数据时。<br>在结果集中包括“合计”的例程通常要比使用游标执行的速度快。如果开发时间允许，基于游标的方法和基于集的方法都可以尝试一下，看哪一种方法的效果更好。</p>
</li>
<li><p>在所有的存储过程和触发器的开始处设置 SET NOCOUNT ON ，在结束时设置 SET NOCOUNT OFF 。无需在执行存储过程和触发器的每个语句后向客户端发送 DONE_IN_PROC 消息。</p>
</li>
<li><p>尽量<strong>避免向客户端返回大数据量</strong>，若数据量过大，应该考虑相应需求是否合理。</p>
</li>
<li><p>尽量<strong>避免大事务操作</strong>，提高系统并发能力。</p>
</li>
</ol>
<h4 id="索引原理"><a href="#索引原理" class="headerlink" title="索引原理"></a>索引原理</h4><h5 id="B-Tree"><a href="#B-Tree" class="headerlink" title="B+Tree"></a>B+Tree</h5><h5 id="资料引用"><a href="#资料引用" class="headerlink" title="资料引用"></a>资料引用</h5><p>关于B-Tree 和 B+Tree 的资料简介：<br><a target="_blank" rel="noopener" href="https://vgbhfive.cn/B-Tree%E5%92%8CB-Tree%E7%9A%84%E6%8E%A2%E7%A7%98%E4%B9%8B%E6%97%85/">https://vgbhfive.cn/B-Tree%E5%92%8CB-Tree%E7%9A%84%E6%8E%A2%E7%A7%98%E4%B9%8B%E6%97%85/</a></p>
<h4 id="主从分库"><a href="#主从分库" class="headerlink" title="主从分库"></a>主从分库</h4><p>在高并发环境下，如何保证数据库能抗住高并发的读和写操作，因此绝大部分都会基于MySQL 的主从复制（replication）来设计，包括常见的<strong>一主一从</strong>、<strong>双主模式</strong>、<strong>半同步复制（semi-sync replication）</strong>。</p>
<h5 id="主从复制"><a href="#主从复制" class="headerlink" title="主从复制"></a>主从复制</h5><p>常见的数据主从同步可以说成是同步的，但是这个过程上确实异步的，大概流程是这样的：</p>
<ul>
<li>在master 上提交事务后，写入binlog，返回事务成功标记。</li>
<li>将binlog 发送到slave ，转储成relay log。</li>
<li>在slave 上再将relay log 读取出来应用。</li>
</ul>
<p>这其中的步骤1 和步骤3 之间是异步进行的，无需等待确认各自的状态，因此可以说MySQL 的主从复制是异步的。</p>
<h5 id="半同步复制"><a href="#半同步复制" class="headerlink" title="半同步复制"></a>半同步复制</h5><p>MySQL semi-sync replication 在之前的基础上做了加强，整体流程变成了这样:</p>
<ul>
<li>首先，master 和slave 都需要启动semi-sync replication 模式。</li>
<li>当某一个slave 连接上master 之后，会主动告知自己当前是否处于semi-sync replication 状态。</li>
<li>在master 上提交事务，写入binlog，此时需要通知一个slave 来接收此事务，等待写入relay log成功并刷新到磁盘后，slave 向master 发送已完成此事务标记。</li>
<li>master 收到slave 的完成事务通知后，此时再返回事务成功标记。</li>
</ul>
<p>所以，上述的流程就存在了一个关键点，<strong>rpl_semi_sync_master_timeout</strong>即salve 向master 发送通知时间限定值，如果超过此限定值，就会从半同步复制转化为主从复制。</p>
<h5 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h5><p>上面主要说了主从复制和半同步复制，那么在MySQL 中，一次事务的提交，需要写入undo、redo、binlog、写数据文件等等，那么在这个过程中，如果出现了crash，就有可能导致主从的数据不一致。</p>
<p>master 配置：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">innodb_flush_log_at_trx_commit = 1     # 每个事务提交时候，把事务日志从缓存区写到日志文件中，并且刷新日志文件的数据到磁盘上</span><br><span class="line">sync_binlog = 100                      # 将binlog 刷新到磁盘上</span><br></pre></td></tr></table></figure>

<p>slave 配置：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">master_info_repository = &quot;TABLE&quot;       # 确保在slave上和复制相关的元数据表也采用InnoDB引擎，受到InnoDB事务安全的保护</span><br><span class="line">relay_log_info_repository = &quot;TABLE&quot;    # 确保在slave上和复制相关的元数据表也采用InnoDB引擎，受到InnoDB事务安全的保护</span><br><span class="line">relay_log_recovery = 1                 # 开启relay log自动修复机制，发生crash时，会自动判断哪些relay log需要重新从master上抓取回来再次应用，以此避免部分数据丢失的可能性</span><br></pre></td></tr></table></figure>

<p>经过上述的配置，就可以确保主从配置不会将数据丢失，但是这又不能保证主从数据库的数据一致性了。<br>但是，别灰心，毕竟有舍才有得嘛！</p>
<hr>

<h3 id="面试"><a href="#面试" class="headerlink" title="面试"></a>面试</h3><h4 id="SQL-攻击"><a href="#SQL-攻击" class="headerlink" title="SQL 攻击"></a>SQL 攻击</h4><p>由于浏览器的同源策略并不允许其他网站去访问别的网站的cookie，但并不限制&lt;/img&gt;标签去别的网站下载图片，所以此时可以创建一个不可见的img ，将用户cookie 利用img 发送到本机服务器。<br><img src="https://i.loli.net/2019/08/09/EtcuCBm9szT7L4I.jpg" alt="1.jpg"><br>应对方法，采用HttpOnly 拒绝使用JavaScript 读取即可防止。</p>
<h4 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a>Explain</h4><p>Explain 可以使用在SELECT、DELETE、INSERT、REPLACE、UPDATE 等语句中，执行的结果会在每一行显示用到的每一个表的详细信息。<br>简单的语句可能结果就一句，但是复杂的查询语句会有很多行。</p>
<h5 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h5><p>在SQL 语句前加上explain ，如：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">explain <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> users;</span><br></pre></td></tr></table></figure>
<p><a target="_blank" rel="noopener" href="https://i.loli.net/2019/07/22/5d358f50c02b135511.jpg"><img src="https://i.loli.net/2019/07/22/5d358f50c02b135511.jpg" alt="1.jpg"></a></p>
<h5 id="Explain-输出分析"><a href="#Explain-输出分析" class="headerlink" title="Explain 输出分析"></a>Explain 输出分析</h5><ol>
<li>id: 是用来顺序标识整个查询中select 语句的，在嵌套查询中id越大的语句越先执行。</li>
<li>select_type:查询语句类型。</li>
</ol>
<ul>
<li>simple: 简单的SELECT（不使用UNION或子查询）。</li>
<li>primary: 最外面的SELECT 。</li>
<li>union: UNION 中的第二个或更高的SELECT 语句</li>
<li>dependent union: UNION 中的第二个或更高的SELECT 语句，取决于外部查询。</li>
<li>union result: UNION 的结果。</li>
<li>subquery: 在子查询中首先选择SELECT 。</li>
<li>dependent subquery: 子查询中的第一个SELECT ，取决于外部查询。</li>
<li>derived: 派生表——该临时表是从子查询派生出来的，位于from 中的子查询。</li>
<li>uncacheable subquery: 无法缓存结果的子查询，必须为外部查询的每一行重新计算。</li>
<li>uncacheable union: 在UNION 中的第二个或更晚的选择属于不可缓存的子查询。</li>
</ul>
<ol start="3">
<li>table: 每一行引用的表名。</li>
<li>partitions: 匹配的分区。</li>
<li>type: 访问类型。从上到下效果依次降低：</li>
</ol>
<ul>
<li>system: const 的一种特例，表中只有一行数据。</li>
<li>const: 当确定最多只会有一行匹配的时候，MySQL 优化器会在查询前读取它而且只读取一次，因此非常快。使用主键查询往往就是const 级别的，非常高效。</li>
<li>eq_ref: 最多只返回一条符合条件的记录，通过使用在两个表有关联字段的时候。</li>
<li>ref: 通过普通索引查询匹配的很多行时的类型。</li>
<li>fulltext: 全文索引。</li>
<li>ref_or_null: 跟ref 类似的效果，不过多一个列不能null 的条件。</li>
<li>index_merge: 此连接类型表示使用了索引合并优化。在这种情况下，输出行中的key 列包含使用的索引列表，key_len 包含所用索引的最长key 部分列表。</li>
<li>unique_subquery: 在使用in 查询的情况下会取代eq_ref 。</li>
<li>range: 范围扫描，一个有限制的索引扫描。key 列显示使用了哪个索引。当使用&#x3D;、 &lt;&gt;、&gt;、&gt;&#x3D;、&lt;、&lt;&#x3D;、IS NULL、&lt;&#x3D;&gt;、BETWEEN 或者IN 操作符，用常量比较关键字列时,可以使用range 。</li>
<li>index: 类似全表扫描，只是扫描表的时候按照索引次序进行而不是行。主要优点就是避免了排序, 但是开销仍然非常大。<br> 如在Extra 列看到Using index，说明正在使用覆盖索引，只扫描索引的数据，它比按索引次序全表扫描的开销要小很多。</li>
<li>ALL: 全表扫描。</li>
</ul>
<ol start="6">
<li>possible_keys: MySQL 可能采用的索引，但是并不一定使用。</li>
<li>key: MySQL 正真使用的索引名称。</li>
<li>key_lens: 索引key 的长度。</li>
<li>ref: 显示之前的表在key 列记录的索引中查找值所用的列或常量。</li>
<li>rows: 预估的扫描行数，只能参考不准确。</li>
<li>filtered: 查询的表行占表的百分比。</li>
<li>extra: 该列包含了很多额外的信息，包括是否文件排序，是否有临时表等，很多时候这个字段很有用能提供很多信息。</li>
</ol>
<hr>

<h3 id="技巧和案例"><a href="#技巧和案例" class="headerlink" title="技巧和案例"></a>技巧和案例</h3><h4 id="SQL-SSM-实战"><a href="#SQL-SSM-实战" class="headerlink" title="SQL SSM 实战"></a>SQL SSM 实战</h4><ol>
<li><p>根据多条件随机条件查询</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">select * from t_user_info where 1 = 1</span><br><span class="line">&lt;if test=&quot;userId != null and userId != &#x27;&#x27;&quot;&gt;</span><br><span class="line">   and userId = #&#123;userId&#125;</span><br><span class="line">&lt;/if&gt;</span><br><span class="line">&lt;if test=&quot;userName != null and userName != &#x27;&#x27;&quot;&gt;</span><br><span class="line">   and userName = #&#123;userName&#125;</span><br><span class="line">&lt;/if&gt;</span><br><span class="line">&lt;if test=&quot;userId != null and userId != &#x27;&#x27;&quot;&gt;</span><br><span class="line">   and userId IN</span><br><span class="line">   &lt;foreach item=&quot;userId&quot; collection=&quot;userIds&quot; index=&quot;index&quot; open=&quot;(&quot; separator=&quot;,&quot; close=&quot;)&quot;&gt;</span><br><span class="line">      #&#123;userId&#125;</span><br><span class="line">   &lt;/foreach&gt;</span><br><span class="line">&lt;/if&gt;</span><br><span class="line">&lt;if test=&quot;beginDate != null and beginDate != &#x27;&#x27; and endDate != null and endDate != &#x27;&#x27;&quot;&gt;</span><br><span class="line">   and date(CREATE_DATE) BETWEEN #&#123;beginDate&#125; AND #&#123;endDate&#125;</span><br><span class="line">&lt;/if&gt;</span><br><span class="line">&lt;if test=&quot;startRows != null and pageSize !=&#x27;&#x27;&quot;&gt;</span><br><span class="line">   LIMIT #&#123;startRows&#125;,#&#123;pageSize&#125;</span><br><span class="line">&lt;/if&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>根据条件计数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">select count(*) from t_user_info where 1 = 1</span><br><span class="line">&lt;if test=&quot;userId != null and userId != &#x27;&#x27;&quot;&gt;</span><br><span class="line">   and userId = #&#123;userId&#125;</span><br><span class="line">&lt;/if&gt;</span><br><span class="line">&lt;if test=&quot;userName != null and userName != &#x27;&#x27;&quot;&gt;</span><br><span class="line">   and userName = #&#123;userName&#125;</span><br><span class="line">&lt;/if&gt;</span><br><span class="line">&lt;if test=&quot;startRows != null and pageSize !=&#x27;&#x27;&quot;&gt;</span><br><span class="line">   LIMIT #&#123;startRows&#125;,#&#123;pageSize&#125;</span><br><span class="line">&lt;/if&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>多表联合查询</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SELECT a.*, b.* FROM (</span><br><span class="line">   SELECT * FROM t_user_info WHERE id = #&#123;id&#125; </span><br><span class="line">) a,</span><br><span class="line">t_user_home_info b WHERE a.id = b.apply_id</span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="读写分离"><a href="#读写分离" class="headerlink" title="读写分离"></a>读写分离</h4><p><a target="_blank" rel="noopener" href="https://github.com/chenlei2/spring-boot-mybatis-rw">https://github.com/chenlei2/spring-boot-mybatis-rw</a></p>
<h4 id="数据库减负"><a href="#数据库减负" class="headerlink" title="数据库减负"></a>数据库减负</h4><p>海量数据，光用数据库肯定是没法搞定的，所以可以从一下几个方面着手解决。</p>
<h5 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h5><p>第一种解决方案就是缓存。<br>缓存，我们可以将数据直接缓存在内从中。例如Map 也可以使用缓存框架，如Redis 等，将一些需要频繁使用的热点数据保存在缓存中，每当用户来访问的时候，就可以直接将缓存中的数据返回给用户，这样可以有效降低服务器的压力。<br>另外可以缓存起来使用的数据，一般都不能对实时性要求太高。</p>
<h5 id="页面静态化"><a href="#页面静态化" class="headerlink" title="页面静态化"></a>页面静态化</h5><p>页面静态化其实可以算作是缓存的另外一种形式，相当于直接将相关的页面渲染结果缓存起来。<br>首先大家知道，在我们的 Web 项目中，资源分为两大类：</p>
<ul>
<li>静态资源</li>
<li>动态资源</li>
</ul>
<p>静态资源就是我们常见的HTML、CSS、JavaScript 图片等资源，这些资源可以不经过服务端处理，就可以直接返回给前端浏览器，浏览器就可以直接显示出来。<br>动态资源则是指我们项目中的Servlet 接口、Jsp 文件、Freemarker 等，这些需要经过服务端渲染之后，才可以返回前端的资源。<br>在实际项目中，静态资源的访问速度要远远高于动态资源，动态资源往往很容易遇到服务器瓶颈、数据库瓶颈。<br>因此，对于一些不经常更新的页面，或者说更新比较缓慢的页面，我们可以通过页面静态化，将一个动态资源保存为静态资源，这样当服务端需要访问的时候，直接将静态资源返回，就可以避免去操作数据库了，降低数据库的压力。<br>一般来说，Freemarker、Velocity 等都有相关的方法可以帮助我们快速将动态页面生成静态页面。</p>
<h5 id="数据库优化"><a href="#数据库优化" class="headerlink" title="数据库优化"></a>数据库优化</h5><p>很多时候程序跑得慢，不是因为设备落后，而是因为数据库SQL 写的太差劲。<br>要解决海量数据的问题，数据库优化肯定也是不可避免的。一般来说，我们可以从 SQL 优化、表结构优化、以及数据库分区分表等多个方面来对数据库进行优化。<br>数据库优化其实也是一门巨大的学问，以后有时间可以仔细琢磨琢磨。</p>
<h5 id="热点数据分离"><a href="#热点数据分离" class="headerlink" title="热点数据分离"></a>热点数据分离</h5><p>数据库中的数据，虽然是海量数据，但是这些数据并不见得所有数据都是活跃数据。例如用户注册，有的用户注册完就消失的无影无踪了，而有的用户则在不停的登录。<br>因此，对于这两种不同的用户，我们可以将活跃用户分离出来，在主要操作的数据表中只保存活跃用户数据。<br>每次用户登录，先去主表中查看有没有记录，有的话，直接登录，没有的话，再去查看其他表。</p>
<p>通过判断用户在某一段时间内的登录次数，就可以很快分离出热点数据。</p>
<h5 id="合并数据库操作"><a href="#合并数据库操作" class="headerlink" title="合并数据库操作"></a>合并数据库操作</h5><p>这个方案的宗旨其实是减少数据库操作的次数。例如多次插入操作，我们可以合并成一条SQL 搞定。<br>多个不同条件的查询，如果条件允许的话，也可以合并成为一个查询，尽量减少数据库的操作，减少在网络上消耗，同时也降低数据库的压力。</p>
<h5 id="数据库读写分离"><a href="#数据库读写分离" class="headerlink" title="数据库读写分离"></a>数据库读写分离</h5><p>数据库的读写分离一方面可以提高数据库的操作效率，另一方面也算是对数据库的一个备份。<br>具体的操作可以去看我下边的<em>技巧与案例</em>模块。</p>
<h5 id="分布式数据库"><a href="#分布式数据库" class="headerlink" title="分布式数据库"></a>分布式数据库</h5><p>数据库读写分离之后，无形中增大了代码的复杂度，所以一般还需要借助分布式数据库中间件，这样可以有效提高数据库的弹性，可以方便的随时为数据库扩容，同时也降低代码的耦合度。</p>
<h5 id="NoSQL-和Hadoop"><a href="#NoSQL-和Hadoop" class="headerlink" title="NoSQL 和Hadoop"></a>NoSQL 和Hadoop</h5><p>引入NoSQL 和Hadoop 也是解决方案之一。<br>NoSQL 突破了关系型数据库中对表结构、字段等定义的条条框框，使用户可以非常灵活方便的操作，另外NoSQL 通过多个存储块存储数据的特点，使得天然具备操作大数据的优势（快）。<br>不过，老实说，NoSQL 目前还是在互联网项目中比较常见，在传统的企业级应用中还是比较少见。<br>Hadoop 就不必说了，大数据处理利器。</p>
<hr>

<h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/OZ0Uqv7UCiyhhRurNdVi4A">https://mp.weixin.qq.com/s/OZ0Uqv7UCiyhhRurNdVi4A</a><br><a target="_blank" rel="noopener" href="https://juejin.im/user/57cc22b87db2a2007898d792/posts">https://juejin.im/user/57cc22b87db2a2007898d792/posts</a> -MySQL系列</p>
<hr>

<h3 id="个人备注"><a href="#个人备注" class="headerlink" title="个人备注"></a>个人备注</h3><p><strong>此博客内容均为作者学习所做笔记，侵删！</strong><br><strong>若转作其他用途，请注明来源！</strong></p>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/MySQL/" rel="tag"># MySQL</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/SpringBoot-%E8%87%AA%E5%AE%9A%E4%B9%89favicon/" rel="prev" title="SpringBoot-自定义favicon">
      <i class="fa fa-chevron-left"></i> SpringBoot-自定义favicon
    </a></div>
      <div class="post-nav-item">
    <a href="/Nginx-%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8%E5%92%8C%E6%8F%90%E9%AB%98/" rel="next" title="Nginx-快速入门和提高">
      Nginx-快速入门和提高 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9F%BA%E7%A1%80"><span class="nav-number">1.</span> <span class="nav-text">基础</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%AE%80%E4%BB%8B"><span class="nav-number">1.1.</span> <span class="nav-text">简介</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%89%E8%A3%85"><span class="nav-number">1.2.</span> <span class="nav-text">安装</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#Linux"><span class="nav-number">1.2.1.</span> <span class="nav-text">Linux</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Windows"><span class="nav-number">1.2.2.</span> <span class="nav-text">Windows</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%85%83%E6%95%B0%E6%8D%AE"><span class="nav-number">1.2.3.</span> <span class="nav-text">元数据</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95"><span class="nav-number">1.3.</span> <span class="nav-text">基础语法</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%93%8D%E4%BD%9C%E6%95%B0%E6%8D%AE%E5%BA%93"><span class="nav-number">1.3.1.</span> <span class="nav-text">操作数据库</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="nav-number">1.3.2.</span> <span class="nav-text">数据类型</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#CURD"><span class="nav-number">1.3.3.</span> <span class="nav-text">CURD</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#UNION"><span class="nav-number">1.3.4.</span> <span class="nav-text">UNION</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%88%86%E7%BB%84%E3%80%81%E6%8E%92%E5%BA%8F"><span class="nav-number">1.3.5.</span> <span class="nav-text">分组、排序</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%BF%9E%E6%8E%A5"><span class="nav-number">1.3.6.</span> <span class="nav-text">连接</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#NULL%E5%80%BC%E5%A4%84%E7%90%86"><span class="nav-number">1.3.7.</span> <span class="nav-text">NULL值处理</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%AB%98%E7%BA%A7"><span class="nav-number">2.</span> <span class="nav-text">高级</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="nav-number">2.1.</span> <span class="nav-text">正则表达式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BA%8B%E5%8A%A1"><span class="nav-number">2.2.</span> <span class="nav-text">事务</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB"><span class="nav-number">2.2.1.</span> <span class="nav-text">隔离级别</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BA%8B%E5%8A%A1%E6%97%A5%E5%BF%97"><span class="nav-number">2.2.2.</span> <span class="nav-text">事务日志</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%94%81"><span class="nav-number">2.3.</span> <span class="nav-text">锁</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%AF%BB%E5%86%99%E9%94%81"><span class="nav-number">2.3.1.</span> <span class="nav-text">读写锁</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%94%81%E7%B2%92%E5%BA%A6"><span class="nav-number">2.3.2.</span> <span class="nav-text">锁粒度</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%B4%A2%E5%BC%95"><span class="nav-number">2.4.</span> <span class="nav-text">索引</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%B4%E6%97%B6%E8%A1%A8"><span class="nav-number">2.5.</span> <span class="nav-text">临时表</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A4%8D%E5%88%B6%E8%A1%A8"><span class="nav-number">2.6.</span> <span class="nav-text">复制表</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BA%8F%E5%88%97"><span class="nav-number">2.7.</span> <span class="nav-text">序列</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#SQL-%E6%B3%A8%E5%85%A5"><span class="nav-number">2.8.</span> <span class="nav-text">SQL 注入</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AF%BC%E5%85%A5%E3%80%81%E5%AF%BC%E5%87%BA%E6%95%B0%E6%8D%AE"><span class="nav-number">2.9.</span> <span class="nav-text">导入、导出数据</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BF%90%E7%AE%97%E7%AC%A6%E3%80%81%E5%87%BD%E6%95%B0"><span class="nav-number">2.10.</span> <span class="nav-text">运算符、函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%97%A5%E5%BF%97"><span class="nav-number">2.11.</span> <span class="nav-text">日志</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%87%8D%E5%81%9A%E6%97%A5%E5%BF%97"><span class="nav-number">2.11.1.</span> <span class="nav-text">重做日志</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%9B%9E%E6%BB%9A%E6%97%A5%E5%BF%97"><span class="nav-number">2.11.2.</span> <span class="nav-text">回滚日志</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%97%A5%E5%BF%97"><span class="nav-number">2.11.3.</span> <span class="nav-text">二进制日志</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%B8%AD%E7%BB%A7%E6%97%A5%E5%BF%97"><span class="nav-number">2.11.4.</span> <span class="nav-text">中继日志</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BC%98%E5%8C%96"><span class="nav-number">3.</span> <span class="nav-text">优化</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9E%B6%E6%9E%84"><span class="nav-number">3.1.</span> <span class="nav-text">架构</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%A1%86%E6%9E%B6"><span class="nav-number">3.1.1.</span> <span class="nav-text">框架</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%BF%9E%E6%8E%A5%E7%AE%A1%E7%90%86%E5%92%8C%E5%AE%89%E5%85%A8"><span class="nav-number">3.1.2.</span> <span class="nav-text">连接管理和安全</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BC%98%E5%8C%96%E5%92%8C%E6%89%A7%E8%A1%8C"><span class="nav-number">3.1.3.</span> <span class="nav-text">优化和执行</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E"><span class="nav-number">3.2.</span> <span class="nav-text">存储引擎</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#MyISAM"><span class="nav-number">3.2.1.</span> <span class="nav-text">MyISAM</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#InnoDB"><span class="nav-number">3.2.2.</span> <span class="nav-text">InnoDB</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#MyISAM-%E4%B8%8EInnoDB-%E5%AF%B9%E6%AF%94"><span class="nav-number">3.2.3.</span> <span class="nav-text">MyISAM 与InnoDB 对比</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%85%B6%E4%BB%96%E5%BC%95%E6%93%8E"><span class="nav-number">3.2.4.</span> <span class="nav-text">其他引擎</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%A7%84%E8%8C%83"><span class="nav-number">3.3.</span> <span class="nav-text">规范</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%91%BD%E4%BB%A4%E8%A7%84%E8%8C%83"><span class="nav-number">3.3.1.</span> <span class="nav-text">命令规范</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E8%AE%BE%E8%AE%A1%E8%A7%84%E8%8C%83"><span class="nav-number">3.3.2.</span> <span class="nav-text">基本设计规范</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%AD%97%E6%AE%B5%E8%AE%BE%E8%AE%A1%E8%A7%84%E8%8C%83"><span class="nav-number">3.3.3.</span> <span class="nav-text">字段设计规范</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%B4%A2%E5%BC%95%E8%AE%BE%E8%AE%A1%E8%A7%84%E8%8C%83"><span class="nav-number">3.3.4.</span> <span class="nav-text">索引设计规范</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%B4%A2%E5%BC%95%E5%88%97%E5%BB%BA%E8%AE%AE"><span class="nav-number">3.3.5.</span> <span class="nav-text">索引列建议</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%80%89%E6%8B%A9%E7%B4%A2%E5%BC%95%E5%88%97%E7%9A%84%E9%A1%BA%E5%BA%8F"><span class="nav-number">3.3.6.</span> <span class="nav-text">选择索引列的顺序</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%BB%BA%E7%AB%8B%E5%86%97%E4%BD%99%E7%B4%A2%E5%BC%95%E5%92%8C%E9%87%8D%E5%A4%8D%E7%B4%A2%E5%BC%95"><span class="nav-number">3.3.7.</span> <span class="nav-text">建立冗余索引和重复索引</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%80%83%E8%99%91%E8%A6%86%E7%9B%96%E7%B4%A2%E5%BC%95"><span class="nav-number">3.3.8.</span> <span class="nav-text">考虑覆盖索引</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%B4%A2%E5%BC%95SET-%E8%A7%84%E8%8C%83"><span class="nav-number">3.3.9.</span> <span class="nav-text">索引SET 规范</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#SQL-%E5%BC%80%E5%8F%91%E8%A7%84%E8%8C%83"><span class="nav-number">3.3.10.</span> <span class="nav-text">SQL 开发规范</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%93%8D%E4%BD%9C%E8%A1%8C%E4%B8%BA%E8%A7%84%E8%8C%83"><span class="nav-number">3.3.11.</span> <span class="nav-text">操作行为规范</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%AF%AD%E6%B3%95%E4%BC%98%E5%8C%96"><span class="nav-number">3.4.</span> <span class="nav-text">语法优化</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BB%93%E6%9E%84%E4%BC%98%E5%8C%96"><span class="nav-number">3.5.</span> <span class="nav-text">结构优化</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%B4%A2%E5%BC%95%E5%8E%9F%E7%90%86"><span class="nav-number">3.6.</span> <span class="nav-text">索引原理</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#B-Tree"><span class="nav-number">3.6.1.</span> <span class="nav-text">B+Tree</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%B5%84%E6%96%99%E5%BC%95%E7%94%A8"><span class="nav-number">3.6.2.</span> <span class="nav-text">资料引用</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%BB%E4%BB%8E%E5%88%86%E5%BA%93"><span class="nav-number">3.7.</span> <span class="nav-text">主从分库</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6"><span class="nav-number">3.7.1.</span> <span class="nav-text">主从复制</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%8D%8A%E5%90%8C%E6%AD%A5%E5%A4%8D%E5%88%B6"><span class="nav-number">3.7.2.</span> <span class="nav-text">半同步复制</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%85%8D%E7%BD%AE"><span class="nav-number">3.7.3.</span> <span class="nav-text">配置</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9D%A2%E8%AF%95"><span class="nav-number">4.</span> <span class="nav-text">面试</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#SQL-%E6%94%BB%E5%87%BB"><span class="nav-number">4.1.</span> <span class="nav-text">SQL 攻击</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Explain"><span class="nav-number">4.2.</span> <span class="nav-text">Explain</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8"><span class="nav-number">4.2.1.</span> <span class="nav-text">使用</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Explain-%E8%BE%93%E5%87%BA%E5%88%86%E6%9E%90"><span class="nav-number">4.2.2.</span> <span class="nav-text">Explain 输出分析</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8A%80%E5%B7%A7%E5%92%8C%E6%A1%88%E4%BE%8B"><span class="nav-number">5.</span> <span class="nav-text">技巧和案例</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#SQL-SSM-%E5%AE%9E%E6%88%98"><span class="nav-number">5.1.</span> <span class="nav-text">SQL SSM 实战</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%AF%BB%E5%86%99%E5%88%86%E7%A6%BB"><span class="nav-number">5.2.</span> <span class="nav-text">读写分离</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E5%87%8F%E8%B4%9F"><span class="nav-number">5.3.</span> <span class="nav-text">数据库减负</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%BC%93%E5%AD%98"><span class="nav-number">5.3.1.</span> <span class="nav-text">缓存</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%A1%B5%E9%9D%A2%E9%9D%99%E6%80%81%E5%8C%96"><span class="nav-number">5.3.2.</span> <span class="nav-text">页面静态化</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BC%98%E5%8C%96"><span class="nav-number">5.3.3.</span> <span class="nav-text">数据库优化</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%83%AD%E7%82%B9%E6%95%B0%E6%8D%AE%E5%88%86%E7%A6%BB"><span class="nav-number">5.3.4.</span> <span class="nav-text">热点数据分离</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%90%88%E5%B9%B6%E6%95%B0%E6%8D%AE%E5%BA%93%E6%93%8D%E4%BD%9C"><span class="nav-number">5.3.5.</span> <span class="nav-text">合并数据库操作</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AF%BB%E5%86%99%E5%88%86%E7%A6%BB"><span class="nav-number">5.3.6.</span> <span class="nav-text">数据库读写分离</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%88%86%E5%B8%83%E5%BC%8F%E6%95%B0%E6%8D%AE%E5%BA%93"><span class="nav-number">5.3.7.</span> <span class="nav-text">分布式数据库</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#NoSQL-%E5%92%8CHadoop"><span class="nav-number">5.3.8.</span> <span class="nav-text">NoSQL 和Hadoop</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BC%95%E7%94%A8"><span class="nav-number">6.</span> <span class="nav-text">引用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%AA%E4%BA%BA%E5%A4%87%E6%B3%A8"><span class="nav-number">7.</span> <span class="nav-text">个人备注</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="vgbhfive"
      src="https://i.loli.net/2019/12/10/JF3dKDSkZoPz7h6.jpg">
  <p class="site-author-name" itemprop="name">vgbhfive</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">121</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">44</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/vgbhfive" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;vgbhfive" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:vgbhfive@foxmail.com" title="E-Mail → mailto:vgbhfive@foxmail.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://weibo.com/5655843279" title="Weibo → https:&#x2F;&#x2F;weibo.com&#x2F;5655843279" rel="noopener" target="_blank"><i class="fab fa-weibo fa-fw"></i>Weibo</a>
      </span>
  </div>



      </div>
        <div class="back-to-top motion-element">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        
  <div class="beian"><a href="https://beian.miit.gov.cn/" rel="noopener" target="_blank">陕ICP20002937号 </a>
  </div>

<div class="copyright">
  
  &copy; 2016 – 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">vgbhfive</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a>
  </div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="Total Visitors">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="Total Views">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
